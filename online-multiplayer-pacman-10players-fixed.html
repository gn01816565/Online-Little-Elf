<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç·šä¸Šå¤šäººå°ç²¾éˆéŠæˆ² (10äººç‰ˆ)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .menu-screen, .game-screen {
            display: none;
        }
        
        .menu-screen.active, .game-screen.active {
            display: block;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 400px;
            margin: 0 auto;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .input-group {
            margin: 20px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: bold;
        }
        
        .input-group input {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            outline: none;
        }
        
        .input-group input:focus {
            border-color: #764ba2;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .room-code {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }
        
        .room-code h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .room-code .code {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            letter-spacing: 5px;
            font-family: monospace;
        }
        
        .players-list {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .players-list h3 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .player-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .player-info {
            padding: 10px 15px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }
        
        canvas {
            display: block;
            background: #000;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin: 0 auto;
            max-width: 100%;
        }
        
        .game-controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .status-message {
            text-align: center;
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-message.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status-message.warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .back-button {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            margin-top: 10px;
        }

        .language-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .language-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .language-toggle:active {
            transform: translateY(0);
        }

        /* ğŸ® è™›æ“¬æ–æ¡¿æ¨£å¼ï¼ˆç§»å‹•ç«¯ï¼‰ */
        .virtual-joystick {
            display: none; /* é è¨­éš±è— */
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            z-index: 1000;
            touch-action: none; /* é˜²æ­¢è§¸æ§æ»¾å‹• */
            opacity: 0.85; /* åŠé€æ˜ï¼Œé¿å…é®æ“‹éŠæˆ²ç•«é¢ */
        }

        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.2) 100%);
            border: 3px solid rgba(102, 126, 234, 0.5);
            border-radius: 50%;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease-out;
        }

        .joystick-stick.active {
            background: radial-gradient(circle, #764ba2 0%, #667eea 100%);
            box-shadow: 0 3px 15px rgba(102, 126, 234, 0.6);
        }

        /* ğŸ“± ç§»å‹•ç«¯é©é… */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
                border-radius: 10px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            button {
                padding: 12px 24px;
                font-size: 1em;
            }

            .language-toggle {
                top: 10px;
                right: 10px;
                padding: 8px 16px;
                font-size: 0.9em;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }

            .virtual-joystick {
                display: block; /* ç§»å‹•ç«¯é¡¯ç¤ºè™›æ“¬æ–æ¡¿ */
                width: 120px;
                height: 120px;
                bottom: 20px;
                left: 20px;
            }

            .joystick-stick {
                width: 50px;
                height: 50px;
            }

            .info-panel {
                grid-template-columns: 1fr;
            }

            .player-info {
                font-size: 0.8em;
                padding: 8px 12px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em;
            }

            .container {
                padding: 10px;
            }

            button {
                padding: 10px 20px;
                font-size: 0.9em;
            }

            .virtual-joystick {
                width: 100px;
                height: 100px;
                bottom: 15px;
                left: 15px;
            }

            .joystick-stick {
                width: 40px;
                height: 40px;
            }

            .language-toggle {
                padding: 6px 12px;
                font-size: 0.8em;
            }
        }

        /* ğŸ–¥ï¸ æ¡Œé¢ç«¯éš±è—è™›æ“¬æ–æ¡¿ï¼Œé¡¯ç¤ºéµç›¤æç¤º */
        .keyboard-hint {
            display: block;
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .keyboard-hint {
                display: none; /* ç§»å‹•ç«¯éš±è—éµç›¤æç¤º */
            }
        }
    </style>
</head>
<body>
    <button class="language-toggle" id="languageToggle">
        <span id="langIcon">ğŸŒ</span>
        <span id="langText">English</span>
    </button>

    <div class="container">
        <h1 id="mainTitle">ğŸ® ç·šä¸Šå¤šäººå°ç²¾éˆ (æœ€å¤š10äºº) ğŸ®</h1>
        
        <!-- ä¸»é¸å–® -->
        <div id="menuScreen" class="menu-screen active">
            <div class="menu-buttons">
                <button id="btnShowCreate"><span id="textBtnCreate">ğŸ¯ å»ºç«‹éŠæˆ²æˆ¿é–“</span></button>
                <button id="btnShowJoin"><span id="textBtnJoin">ğŸšª åŠ å…¥éŠæˆ²æˆ¿é–“</span></button>
            </div>

            <div id="createRoomSection" style="display: none;">
                <div class="input-group">
                    <label id="labelHostName">ä½ çš„æš±ç¨±ï¼š</label>
                    <input type="text" id="hostName" data-placeholder-key="placeholderNickname" placeholder="è¼¸å…¥ä½ çš„æš±ç¨±" maxlength="15">
                </div>
                <button id="btnCreateRoom"><span id="textBtnCreateRoom">å»ºç«‹æˆ¿é–“</span></button>
                <button class="back-button" id="btnBackFromCreate"><span id="textBtnBack1">è¿”å›</span></button>
            </div>

            <div id="joinRoomSection" style="display: none;">
                <div class="input-group">
                    <label id="labelPlayerName">ä½ çš„æš±ç¨±ï¼š</label>
                    <input type="text" id="playerName" data-placeholder-key="placeholderNickname" placeholder="è¼¸å…¥ä½ çš„æš±ç¨±" maxlength="15">
                </div>
                <div class="input-group">
                    <label id="labelRoomCode">æˆ¿é–“ä»£ç¢¼ï¼š</label>
                    <input type="text" id="roomCode" data-placeholder-key="placeholderRoomCode" placeholder="è¼¸å…¥6ä½æ•¸æˆ¿é–“ä»£ç¢¼" maxlength="6">
                </div>
                <button id="btnJoinRoom"><span id="textBtnJoinRoom">åŠ å…¥æˆ¿é–“</span></button>
                <button class="back-button" id="btnBackFromJoin"><span id="textBtnBack2">è¿”å›</span></button>
            </div>
        </div>
        
        <!-- ç­‰å¾…å®¤ -->
        <div id="lobbyScreen" class="menu-screen">
            <div class="room-code">
                <h3 id="textRoomCodeTitle">æˆ¿é–“ä»£ç¢¼</h3>
                <div class="code" id="displayRoomCode"></div>
                <p id="textShareCode" style="margin-top: 10px; color: #666;">åˆ†äº«æ­¤ä»£ç¢¼çµ¦æœ‹å‹åŠ å…¥éŠæˆ²</p>
            </div>

            <div class="players-list">
                <h3><span id="textPlayersJoined">å·²åŠ å…¥ç©å®¶</span> (<span id="playerCount">0</span>/10)</h3>
                <div id="playersList"></div>
            </div>

            <div class="status-message info">
                <span id="textWaitingMessage">ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥... (è‡³å°‘éœ€è¦2ä½ç©å®¶)</span>
            </div>

            <button id="startButton" disabled><span id="textBtnStart">é–‹å§‹éŠæˆ²</span></button>
            <button class="back-button" id="btnLeaveLobby"><span id="textBtnLeaveLobby">é›¢é–‹æˆ¿é–“</span></button>
        </div>
        
        <!-- éŠæˆ²ç•«é¢ -->
        <div id="gameScreen" class="game-screen">
            <div class="info-panel" id="gameInfoPanel"></div>

            <canvas id="gameCanvas" width="1000" height="800"></canvas>

            <div class="game-controls">
                <p id="textControls" style="margin-bottom: 10px; color: #666;">
                    ä½¿ç”¨æ–¹å‘éµ â†‘ â†“ â† â†’ æˆ– W A S D ç§»å‹•
                </p>
                <button id="btnToggleSound" style="margin-bottom: 10px;"><span id="textSoundToggle">ğŸ”Š éŸ³æ•ˆï¼šé–‹å•Ÿ</span></button>
                <button class="back-button" id="btnLeaveGame"><span id="textBtnLeaveGame">é›¢é–‹éŠæˆ²</span></button>
            </div>
        </div>
    </div>

    <!-- ğŸ® è™›æ“¬æ–æ¡¿ï¼ˆç§»å‹•ç«¯ï¼‰ -->
    <div class="virtual-joystick" id="virtualJoystick">
        <div class="joystick-base"></div>
        <div class="joystick-stick" id="joystickStick"></div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <script>
        // Firebase é…ç½® - è«‹æ›¿æ›ç‚ºä½ è‡ªå·±çš„é…ç½®
        const firebaseConfig = {
            apiKey: "AIzaSyBexampleKey123456789",
            authDomain: "your-project.firebaseapp.com",
            databaseURL: "https://your-project-default-rtdb.firebaseio.com",
            projectId: "your-project",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdef123456"
        };

        // åˆå§‹åŒ– Firebase
        let database;
        let isDemo = false;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.log('Firebase é…ç½®éŒ¯èª¤ - ä½¿ç”¨æ¼”ç¤ºæ¨¡å¼', error);
            isDemo = true;
            // ä¸é¡¯ç¤º alertï¼Œè®“æ¸¬è©¦ç¹¼çºŒ
        }

        // ===========================================
        // ğŸŒ é›™èªç³»çµ± (Traditional Chinese / English)
        // ===========================================
        const translations = {
            'zh-TW': {
                // Page title
                pageTitle: 'ç·šä¸Šå¤šäººå°ç²¾éˆéŠæˆ² (10äººç‰ˆ)',
                mainTitle: 'ğŸ® ç·šä¸Šå¤šäººå°ç²¾éˆ (æœ€å¤š10äºº) ğŸ®',

                // Menu buttons
                btnCreate: 'ğŸ¯ å»ºç«‹éŠæˆ²æˆ¿é–“',
                btnJoin: 'ğŸšª åŠ å…¥éŠæˆ²æˆ¿é–“',
                btnCreateRoom: 'å»ºç«‹æˆ¿é–“',
                btnJoinRoom: 'åŠ å…¥æˆ¿é–“',
                btnBack: 'è¿”å›',
                btnStart: 'é–‹å§‹éŠæˆ²',
                btnLeaveLobby: 'é›¢é–‹æˆ¿é–“',
                btnLeaveGame: 'é›¢é–‹éŠæˆ²',

                // Labels
                labelNickname: 'ä½ çš„æš±ç¨±ï¼š',
                labelRoomCode: 'æˆ¿é–“ä»£ç¢¼ï¼š',
                placeholderNickname: 'è¼¸å…¥ä½ çš„æš±ç¨±',
                placeholderRoomCode: 'è¼¸å…¥6ä½æ•¸æˆ¿é–“ä»£ç¢¼',

                // Lobby
                roomCodeTitle: 'æˆ¿é–“ä»£ç¢¼',
                shareCode: 'åˆ†äº«æ­¤ä»£ç¢¼çµ¦æœ‹å‹åŠ å…¥éŠæˆ²',
                playersJoined: 'å·²åŠ å…¥ç©å®¶',
                waitingMessage: 'ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥... (è‡³å°‘éœ€è¦2ä½ç©å®¶)',

                // Game controls
                controls: 'ä½¿ç”¨æ–¹å‘éµ â†‘ â†“ â† â†’ æˆ– W A S D ç§»å‹•',
                soundOn: 'ğŸ”Š éŸ³æ•ˆï¼šé–‹å•Ÿ',
                soundOff: 'ğŸ”‡ éŸ³æ•ˆï¼šé—œé–‰',

                // Player info
                you: '(ä½ )',
                score: 'åˆ†æ•¸',
                points: 'åˆ†',

                // Alerts
                alertEnterNickname: 'è«‹è¼¸å…¥ä½ çš„æš±ç¨±',
                alertFirebaseNotConfigured: 'Firebase æœªæ­£ç¢ºé…ç½®ï¼Œç„¡æ³•å»ºç«‹æˆ¿é–“',
                alertDemoModeCreate: 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nFirebase æœªé…ç½®ï¼Œç„¡æ³•çœŸæ­£å»ºç«‹ç·šä¸Šæˆ¿é–“ã€‚\né€™åªæ˜¯ç•Œé¢æ¼”ç¤ºã€‚\n\nè¦å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šï¼Œè«‹ä¾ç…§ README é…ç½® Firebaseã€‚',
                alertDemoMode: 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nFirebase æœªé…ç½®ï¼Œç„¡æ³•å•Ÿå‹•éŠæˆ²ã€‚\né€™åªæ˜¯ç•Œé¢æ¼”ç¤ºã€‚\n\nè¦å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šï¼Œè«‹ä¾ç…§ README é…ç½® Firebaseã€‚',
                alertDemoModeJoin: 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nFirebase æœªé…ç½®ï¼Œç„¡æ³•åŠ å…¥ç·šä¸Šæˆ¿é–“ã€‚\n\nè¦å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šï¼Œè«‹ä¾ç…§ README é…ç½® Firebaseã€‚',
                alertFirebaseNotConfiguredJoin: 'Firebase æœªæ­£ç¢ºé…ç½®ï¼Œç„¡æ³•åŠ å…¥æˆ¿é–“',
                alertRoomNotFound: 'æˆ¿é–“ä¸å­˜åœ¨ï¼Œè«‹æª¢æŸ¥æˆ¿é–“ä»£ç¢¼',
                alertInvalidRoomCode: 'è«‹è¼¸å…¥æ­£ç¢ºçš„6ä½æ•¸æˆ¿é–“ä»£ç¢¼',
                alertRoomFull: 'æˆ¿é–“å·²æ»¿ (æœ€å¤š10ä½ç©å®¶)',
                alertGameStarted: 'éŠæˆ²å·²ç¶“é–‹å§‹ï¼Œç„¡æ³•åŠ å…¥',
                alertRoomClosed: 'æˆ¿é–“å·²é—œé–‰',

                // Canvas text
                timer: 'â±ï¸',
                ranking: 'ğŸ† æ’å',
                warning30sec: 'âš ï¸ æœ€å¾Œ 30 ç§’ï¼âš ï¸',
                gameOver: 'ğŸ† éŠæˆ²çµæŸ ğŸ†',
                autoReturn: '15ç§’å¾Œè‡ªå‹•è¿”å›å¤§å»³ï¼Œæˆ–é»æ“Šä¸‹æ–¹æŒ‰éˆ•',

                // Language toggle
                languageToggle: 'English'
            },
            'en': {
                // Page title
                pageTitle: 'Online Multiplayer Pacman (10 Players)',
                mainTitle: 'ğŸ® Online Multiplayer Pacman (Up to 10 Players) ğŸ®',

                // Menu buttons
                btnCreate: 'ğŸ¯ Create Game Room',
                btnJoin: 'ğŸšª Join Game Room',
                btnCreateRoom: 'Create Room',
                btnJoinRoom: 'Join Room',
                btnBack: 'Back',
                btnStart: 'Start Game',
                btnLeaveLobby: 'Leave Room',
                btnLeaveGame: 'Leave Game',

                // Labels
                labelNickname: 'Your Nickname:',
                labelRoomCode: 'Room Code:',
                placeholderNickname: 'Enter your nickname',
                placeholderRoomCode: 'Enter 6-digit room code',

                // Lobby
                roomCodeTitle: 'Room Code',
                shareCode: 'Share this code with friends to join the game',
                playersJoined: 'Players Joined',
                waitingMessage: 'Waiting for other players... (At least 2 players needed)',

                // Game controls
                controls: 'Use Arrow Keys â†‘ â†“ â† â†’ or W A S D to move',
                soundOn: 'ğŸ”Š Sound: ON',
                soundOff: 'ğŸ”‡ Sound: OFF',

                // Player info
                you: '(You)',
                score: 'Score',
                points: 'pts',

                // Alerts
                alertEnterNickname: 'Please enter your nickname',
                alertFirebaseNotConfigured: 'Firebase is not properly configured, cannot create room',
                alertDemoModeCreate: 'âš ï¸ Demo Mode\n\nFirebase is not configured, cannot create online room.\nThis is just a UI demo.\n\nTo enable real multiplayer, please configure Firebase according to the README.',
                alertDemoMode: 'âš ï¸ Demo Mode\n\nFirebase is not configured, cannot start game.\nThis is just a UI demo.\n\nTo enable real multiplayer, please configure Firebase according to the README.',
                alertDemoModeJoin: 'âš ï¸ Demo Mode\n\nFirebase is not configured, cannot join online room.\n\nTo enable real multiplayer, please configure Firebase according to the README.',
                alertFirebaseNotConfiguredJoin: 'Firebase is not properly configured, cannot join room',
                alertRoomNotFound: 'Room does not exist, please check the room code',
                alertInvalidRoomCode: 'Please enter a valid 6-digit room code',
                alertRoomFull: 'Room is full (Maximum 10 players)',
                alertGameStarted: 'Game has already started, cannot join',
                alertRoomClosed: 'Room has been closed',

                // Canvas text
                timer: 'â±ï¸',
                ranking: 'ğŸ† Ranking',
                warning30sec: 'âš ï¸ Last 30 Seconds! âš ï¸',
                gameOver: 'ğŸ† Game Over ğŸ†',
                autoReturn: 'Returning to lobby in 15 seconds, or click the button below',

                // Language toggle
                languageToggle: 'ä¸­æ–‡'
            }
        };

        // Get current language from localStorage or default to 'zh-TW'
        let currentLanguage = localStorage.getItem('gameLanguage') || 'zh-TW';

        // Get translated text
        function t(key) {
            return translations[currentLanguage][key] || translations['zh-TW'][key] || key;
        }

        // Update all UI text elements
        function updateUILanguage() {
            // Update page title
            document.title = t('pageTitle');

            // Update main elements
            const elementsToUpdate = {
                'mainTitle': 'mainTitle',
                'textBtnCreate': 'btnCreate',
                'textBtnJoin': 'btnJoin',
                'labelHostName': 'labelNickname',
                'labelPlayerName': 'labelNickname',
                'labelRoomCode': 'labelRoomCode',
                'textBtnCreateRoom': 'btnCreateRoom',
                'textBtnJoinRoom': 'btnJoinRoom',
                'textBtnBack1': 'btnBack',
                'textBtnBack2': 'btnBack',
                'textRoomCodeTitle': 'roomCodeTitle',
                'textShareCode': 'shareCode',
                'textPlayersJoined': 'playersJoined',
                'textWaitingMessage': 'waitingMessage',
                'textBtnStart': 'btnStart',
                'textBtnLeaveLobby': 'btnLeaveLobby',
                'textControls': 'controls',
                'textBtnLeaveGame': 'btnLeaveGame'
            };

            for (const [elementId, translationKey] of Object.entries(elementsToUpdate)) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = t(translationKey);
                }
            }

            // Update placeholders
            const placeholderElements = document.querySelectorAll('[data-placeholder-key]');
            placeholderElements.forEach(element => {
                const key = element.getAttribute('data-placeholder-key');
                element.placeholder = t(key);
            });

            // Update sound toggle button
            updateSoundButtonText();

            // Update language toggle button
            document.getElementById('langText').textContent = t('languageToggle');
        }

        // Update sound button text based on current state
        function updateSoundButtonText() {
            const soundBtn = document.getElementById('textSoundToggle');
            if (soundBtn) {
                soundBtn.textContent = isSoundEnabled ? t('soundOn') : t('soundOff');
            }
        }

        // Toggle language
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'zh-TW' ? 'en' : 'zh-TW';
            localStorage.setItem('gameLanguage', currentLanguage);
            updateUILanguage();
        }

        // 10ç¨®ä¸åŒé¡è‰²
        const playerColors = [
            '#FFD700',  // é‡‘é»ƒè‰²
            '#FF69B4',  // ç²‰ç´…è‰²
            '#00CED1',  // é’è—è‰²
            '#32CD32',  // ç¶ è‰²
            '#FF6347',  // ç•ªèŒ„ç´…
            '#9370DB',  // ç´«è‰²
            '#FFA500',  // æ©™è‰²
            '#00FA9A',  // ä¸­ç¶ è‰²
            '#FF1493',  // æ·±ç²‰è‰²
            '#4169E1'   // çš‡å®¶è—
        ];

        // ===========================================
        // ğŸ”Š éŸ³æ•ˆç³»çµ±ï¼ˆWeb Audio APIï¼‰
        // ===========================================
        let audioContext = null;
        let isSoundEnabled = true;

        // åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // è§£é–éŸ³æ•ˆï¼ˆæŸäº›ç€è¦½å™¨éœ€è¦ç”¨æˆ¶äº’å‹•ï¼‰
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // æ’­æ”¾éŸ³æ•ˆçš„é€šç”¨å‡½æ•¸
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            if (!isSoundEnabled) return;

            try {
                initAudio();

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.value = frequency;

                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.log('Audio error:', error);
            }
        }

        // 1. åƒå°è±†å­éŸ³æ•ˆ (wakawaka)
        function soundEatDot() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'square';
                osc.frequency.value = 800;

                gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.05);
            } catch (e) { console.log('Audio error:', e); }
        }

        // 2. åƒèƒ½é‡è±†éŸ³æ•ˆ (power-up ä¸Šå‡éŸ³éš)
        function soundEatPowerPellet() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
            const notes = [523, 659, 784, 1047]; // C-E-G-C å’Œå¼¦

                notes.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'triangle';
                    osc.frequency.value = freq;

                    const startTime = audioContext.currentTime + i * 0.08;
                    gain.gain.setValueAtTime(0.25, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);

                    osc.start(startTime);
                    osc.stop(startTime + 0.2);
                });
            } catch (e) { console.log('Audio error:', e); }
        }

        // 3. é€²å…¥èƒ½é‡æ¨¡å¼éŸ³æ•ˆ (è®Šèº«)
        function soundPowerMode() {
            if (!isSoundEnabled) return;
            try {
                initAudio();

                // å¿«é€Ÿä¸Šå‡éŸ³éš
                for (let i = 0; i < 10; i++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'sawtooth';
                    osc.frequency.value = 200 + i * 80;

                    const startTime = audioContext.currentTime + i * 0.03;
                    gain.gain.setValueAtTime(0.2, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);

                    osc.start(startTime);
                    osc.stop(startTime + 0.1);
                }
            } catch (e) { console.log('Audio error:', e); }
        }

        // 4. ç¢°æ’éŸ³æ•ˆ (ç °)
        function soundCollision() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);

                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            } catch (e) { console.log('Audio error:', e); }
        }

        // 5. å¾—åˆ†éŸ³æ•ˆ (å®)
        function soundScore() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'sine';
                osc.frequency.value = 1200;

                gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.15);
            } catch (e) { console.log('Audio error:', e); }
        }

        // 6. èƒ½é‡è±†å³å°‡çµæŸè­¦å‘ŠéŸ³ (å˜Ÿå˜Ÿå˜Ÿ)
        function soundPowerWarning() {
            if (!isSoundEnabled) return;
            try {
                initAudio();

                for (let i = 0; i < 3; i++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'square';
                    osc.frequency.value = 600;

                    const startTime = audioContext.currentTime + i * 0.15;
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.08);

                    osc.start(startTime);
                    osc.stop(startTime + 0.08);
                }
            } catch (e) { console.log('Audio error:', e); }
        }

        // 7. éŠæˆ²å€’æ•¸éŸ³æ•ˆ (æ»´ç­”)
        function soundTick() {
            playSound(800, 0.05, 'square', 0.15);
        }

        // 8. éŠæˆ²çµæŸéŸ³æ•ˆ (å‹åˆ©éŸ³æ¨‚)
        function soundGameEnd() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const melody = [523, 659, 784, 1047, 784, 1047, 1319]; // C-E-G-C-G-C-E

                melody.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    const startTime = audioContext.currentTime + i * 0.15;
                    gain.gain.setValueAtTime(0.25, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            } catch (e) { console.log('Audio error:', e); }
        }

        // ===========================================
        // ğŸ”§ å·¥å…·å‡½æ•¸ï¼šç¯€æµï¼ˆThrottleï¼‰
        // ===========================================
        /**
         * ç¯€æµå‡½æ•¸ï¼šé™åˆ¶å‡½æ•¸åŸ·è¡Œé »ç‡
         * @param {Function} func - è¦åŸ·è¡Œçš„å‡½æ•¸
         * @param {number} delay - å»¶é²æ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
         * @returns {Function} ç¯€æµå¾Œçš„å‡½æ•¸
         */
        function throttle(func, delay) {
            let lastCall = 0;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return func.apply(this, args);
                }
            };
        }

        // ===========================================
        // éŠæˆ²ç‹€æ…‹
        // ===========================================
        let currentRoomId = null;
        let currentPlayerId = null;
        let isHost = false;
        let gameState = null;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CELL_SIZE = 20;
        const COLS = canvas.width / CELL_SIZE;
        const ROWS = canvas.height / CELL_SIZE;
        
        // 10å€‹ä¸åŒçš„èµ·å§‹ä½ç½®
        const startPositions = [
            { x: 2, y: 2 },
            { x: COLS - 3, y: 2 },
            { x: 2, y: ROWS - 3 },
            { x: COLS - 3, y: ROWS - 3 },
            { x: Math.floor(COLS / 2), y: 2 },
            { x: Math.floor(COLS / 2), y: ROWS - 3 },
            { x: 2, y: Math.floor(ROWS / 2) },
            { x: COLS - 3, y: Math.floor(ROWS / 2) },
            { x: Math.floor(COLS / 4), y: Math.floor(ROWS / 4) },
            { x: Math.floor(COLS * 3 / 4), y: Math.floor(ROWS * 3 / 4) }
        ];
        
        // ç”Ÿæˆæˆ¿é–“ä»£ç¢¼
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        // é¡¯ç¤ºå»ºç«‹æˆ¿é–“ç•Œé¢
        function showCreateRoom() {
            console.log('showCreateRoom called');
            document.querySelectorAll('.menu-buttons > button').forEach(b => b.style.display = 'none');
            document.getElementById('createRoomSection').style.display = 'block';
        }
        
        // é¡¯ç¤ºåŠ å…¥æˆ¿é–“ç•Œé¢
        function showJoinRoom() {
            console.log('showJoinRoom called');
            document.querySelectorAll('.menu-buttons > button').forEach(b => b.style.display = 'none');
            document.getElementById('joinRoomSection').style.display = 'block';
        }
        
        // è¿”å›ä¸»é¸å–®
        function backToMenu() {
            document.getElementById('createRoomSection').style.display = 'none';
            document.getElementById('joinRoomSection').style.display = 'none';
            document.querySelectorAll('.menu-buttons > button').forEach(b => b.style.display = 'block');
        }
        
        // å»ºç«‹æˆ¿é–“
        async function createRoom() {
            console.log('createRoom function called');
            const hostName = document.getElementById('hostName').value.trim();
            console.log('Host name:', hostName);

            if (!hostName) {
                alert(t('alertEnterNickname'));
                return;
            }

            console.log('Database status:', database ? 'Available' : 'Not available');

            if (!database) {
                alert(t('alertFirebaseNotConfigured'));
                return;
            }

            console.log('Creating room...');

            const roomCode = generateRoomCode();
            currentRoomId = roomCode;
            currentPlayerId = 'player_' + Date.now();
            isHost = true;

            // æ¼”ç¤ºæ¨¡å¼ - ç›´æ¥åˆ‡æ›åˆ°ç­‰å¾…å®¤
            if (isDemo) {
                console.log('Demo mode - switching to lobby');
                alert(t('alertDemoModeCreate'));
                document.getElementById('menuScreen').classList.remove('active');
                document.getElementById('lobbyScreen').classList.add('active');
                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('playerCount').textContent = '1';
                document.getElementById('playersList').innerHTML = `
                    <div class="player-item" style="background: ${playerColors[0]}20; border: 2px solid ${playerColors[0]}">
                        <div class="player-color-dot" style="background: ${playerColors[0]}"></div>
                        <span style="color: #333">${hostName} ${t('you')}</span>
                    </div>
                `;
                return;
            }
            
            const roomRef = database.ref(`rooms/${roomCode}`);
            const playerRef = database.ref(`rooms/${roomCode}/players/${currentPlayerId}`);
            
            // å»ºç«‹æˆ¿é–“è³‡æ–™
            await roomRef.set({
                code: roomCode,
                status: 'waiting',
                createdAt: Date.now(),
                host: currentPlayerId,
                maxPlayers: 10
            });
            
            // åŠ å…¥ç©å®¶
            const pos = startPositions[0];
            await playerRef.set({
                name: hostName,
                color: playerColors[0],
                score: 0,
                x: pos.x,
                y: pos.y,
                joinedAt: Date.now()
            });
            
            // è¨­å®šæ–·ç·šè™•ç†
            playerRef.onDisconnect().remove();
            
            // ç›£è½æˆ¿é–“è®ŠåŒ–
            listenToRoom();
            
            // åˆ‡æ›åˆ°ç­‰å¾…å®¤
            document.getElementById('menuScreen').classList.remove('active');
            document.getElementById('lobbyScreen').classList.add('active');
            document.getElementById('displayRoomCode').textContent = roomCode;
        }
        
        // åŠ å…¥æˆ¿é–“
        async function joinRoom() {
            console.log('joinRoom function called');
            const playerName = document.getElementById('playerName').value.trim();
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();

            console.log('Player name:', playerName);
            console.log('Room code:', roomCode);

            if (!playerName) {
                alert(t('alertEnterNickname'));
                return;
            }

            if (!roomCode || roomCode.length !== 6) {
                alert(t('alertInvalidRoomCode'));
                return;
            }

            if (isDemo) {
                alert(t('alertDemoModeJoin'));
                return;
            }

            console.log('Database status:', database ? 'Available' : 'Not available');

            if (!database) {
                alert(t('alertFirebaseNotConfiguredJoin'));
                return;
            }

            // æª¢æŸ¥æˆ¿é–“æ˜¯å¦å­˜åœ¨
            const roomRef = database.ref(`rooms/${roomCode}`);
            const snapshot = await roomRef.once('value');

            if (!snapshot.exists()) {
                alert(t('alertRoomNotFound'));
                return;
            }

            const roomData = snapshot.val();
            const playerCount = roomData.players ? Object.keys(roomData.players).length : 0;

            if (playerCount >= 10) {
                alert(t('alertRoomFull'));
                return;
            }

            if (roomData.status === 'playing') {
                alert(t('alertGameStarted'));
                return;
            }
            
            currentRoomId = roomCode;
            currentPlayerId = 'player_' + Date.now();
            
            const playerRef = database.ref(`rooms/${roomCode}/players/${currentPlayerId}`);
            
            // åŠ å…¥ç©å®¶
            const pos = startPositions[playerCount];
            await playerRef.set({
                name: playerName,
                color: playerColors[playerCount],
                score: 0,
                x: pos.x,
                y: pos.y,
                joinedAt: Date.now()
            });
            
            // è¨­å®šæ–·ç·šè™•ç†
            playerRef.onDisconnect().remove();
            
            // ç›£è½æˆ¿é–“è®ŠåŒ–
            listenToRoom();
            
            // åˆ‡æ›åˆ°ç­‰å¾…å®¤
            document.getElementById('menuScreen').classList.remove('active');
            document.getElementById('lobbyScreen').classList.add('active');
            document.getElementById('displayRoomCode').textContent = roomCode;
        }
        
        // ç›£è½æˆ¿é–“è®ŠåŒ–
        function listenToRoom() {
            const roomRef = database.ref(`rooms/${currentRoomId}`);

            roomRef.on('value', (snapshot) => {
                const data = snapshot.val();

                if (!data) {
                    alert(t('alertRoomClosed'));
                    window.location.reload();
                    return;
                }
                
                // æ›´æ–°ç©å®¶åˆ—è¡¨
                updatePlayersList(data.players || {});
                
                // æª¢æŸ¥æ˜¯å¦å¯ä»¥é–‹å§‹éŠæˆ²
                const playerCount = Object.keys(data.players || {}).length;
                const startButton = document.getElementById('startButton');
                if (isHost && playerCount >= 2) {
                    startButton.disabled = false;
                }
                
                // å¦‚æœéŠæˆ²é–‹å§‹ï¼Œåˆ‡æ›åˆ°éŠæˆ²ç•«é¢
                if (data.status === 'playing' && !gameState) {
                    initGame(data);
                } else if (data.status === 'playing' && gameState) {
                    updateGameState(data);
                }
            });
        }
        
        // æ›´æ–°ç©å®¶åˆ—è¡¨
        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            const playerCount = document.getElementById('playerCount');

            playerCount.textContent = Object.keys(players).length;
            playersList.innerHTML = '';

            Object.entries(players).forEach(([id, player]) => {
                const div = document.createElement('div');
                div.className = 'player-item';
                div.style.background = player.color + '20';
                div.style.border = `2px solid ${player.color}`;

                const dot = document.createElement('div');
                dot.className = 'player-color-dot';
                dot.style.background = player.color;

                const name = document.createElement('span');
                name.textContent = `${player.name} ${id === currentPlayerId ? t('you') : ''}`;
                name.style.color = '#333';

                div.appendChild(dot);
                div.appendChild(name);
                playersList.appendChild(div);
            });
        }
        
        // é–‹å§‹éŠæˆ²
        async function startGame() {
            if (!isHost) return;

            // ğŸ”§ æ¼”ç¤ºæ¨¡å¼æª¢æŸ¥
            if (isDemo) {
                alert(t('alertDemoMode') || 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nç„¡æ³•å•Ÿå‹•éŠæˆ²ï¼Œå› ç‚º Firebase æœªé…ç½®ã€‚\nè«‹ä¾ç…§ README è¨­å®š Firebase ä»¥å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šã€‚');
                return;
            }

            if (!database) {
                alert(t('alertFirebaseNotConfigured'));
                return;
            }

            try {
                const roomRef = database.ref(`rooms/${currentRoomId}`);
                const snapshot = await roomRef.once('value');
                const roomData = snapshot.val();

                if (!roomData) {
                    alert(t('alertRoomNotFound'));
                    return;
                }

                // ç”Ÿæˆè¿·å®®
                const maze = generateMaze();

                // æ›´æ–°æˆ¿é–“ç‹€æ…‹
                await roomRef.update({
                    status: 'playing',
                    maze: maze,
                    startedAt: Date.now()
                });

                console.log('Game started successfully');
            } catch (error) {
                console.error('Error starting game:', error);
                alert('å•Ÿå‹•éŠæˆ²æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
            }
        }
        
        /**
         * ç”ŸæˆéŠæˆ²è¿·å®®
         * @returns {Array<Array<number>>} è¿·å®®äºŒç¶­é™£åˆ—
         *
         * åœ°åœ–å…ƒç´ ï¼š
         * - 0: ç©ºåœ°
         * - 1: ç‰†å£
         * - 2: å°è±†å­ï¼ˆ+10 åˆ†ï¼‰
         * - 3: èƒ½é‡è±†ï¼ˆ+50 åˆ†ï¼‰
         *
         * ç”Ÿæˆé‚è¼¯ï¼š
         * 1. å»ºç«‹é‚Šç•Œç‰†ï¼ˆåœ°åœ–å››å‘¨ï¼‰
         * 2. éš¨æ©Ÿç”Ÿæˆå…§éƒ¨ç‰†å£ï¼ˆ12% æ¦‚ç‡ï¼Œåªåœ¨ 3çš„å€æ•¸åº§æ¨™ï¼‰
         * 3. æ”¾ç½®å°è±†å­ï¼ˆ65% æ¦‚ç‡ï¼‰
         * 4. æ¸…ç©ºç©å®¶èµ·å§‹ä½ç½®å‘¨åœå€åŸŸï¼ˆ5x5ï¼‰
         * 5. å›ºå®šæ”¾ç½® 4 å€‹èƒ½é‡è±†åœ¨åœ°åœ–å››è§’
         * 6. æ¸…ç©ºèƒ½é‡è±†å‘¨åœå€åŸŸï¼ˆ3x3ï¼‰
         */
        function generateMaze() {
            const maze = [];

            // æ­¥é©Ÿ 1-3ï¼šç”ŸæˆåŸºæœ¬åœ°åœ–ï¼ˆç‰†å£ã€å°è±†å­ã€ç©ºåœ°ï¼‰
            for (let y = 0; y < ROWS; y++) {
                maze[y] = [];
                for (let x = 0; x < COLS; x++) {
                    if (x === 0 || x === COLS - 1 || y === 0 || y === ROWS - 1) {
                        maze[y][x] = 1; // é‚Šç•Œç‰†
                    } else if (Math.random() < 0.12 && (x % 3 === 0 && y % 3 === 0)) {
                        maze[y][x] = 1; // å…§éƒ¨ç‰†å£ï¼ˆ12% æ¦‚ç‡ï¼Œç¶²æ ¼ç‹€åˆ†å¸ƒï¼‰
                    } else if (Math.random() < 0.65) {
                        maze[y][x] = 2; // å°è±†å­ï¼ˆ65% æ¦‚ç‡ï¼‰
                    } else {
                        maze[y][x] = 0; // ç©ºåœ°ï¼ˆ35% æ¦‚ç‡ï¼‰
                    }
                }
            }

            // æ­¥é©Ÿ 4ï¼šæ¸…ç©ºç©å®¶èµ·å§‹ä½ç½®å‘¨åœï¼ˆç¢ºä¿ç©å®¶å¯ä»¥ç§»å‹•ï¼‰
            startPositions.forEach(pos => {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const ny = pos.y + dy;
                        const nx = pos.x + dx;
                        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                            if (maze[ny][nx] === 1) maze[ny][nx] = 0; // ç§»é™¤ç‰†å£
                        }
                    }
                }
            });

            // æ­¥é©Ÿ 5-6ï¼šå›ºå®šæ”¾ç½® 4 å€‹èƒ½é‡è±†ï¼ˆåœ°åœ–å››è§’ï¼‰
            const powerPelletPositions = [
                { x: 5, y: 5 },                    // å·¦ä¸Šè§’
                { x: COLS - 6, y: 5 },             // å³ä¸Šè§’
                { x: 5, y: ROWS - 6 },             // å·¦ä¸‹è§’
                { x: COLS - 6, y: ROWS - 6 }       // å³ä¸‹è§’
            ];

            powerPelletPositions.forEach(pos => {
                // æ¸…ç©ºèƒ½é‡è±†å‘¨åœå€åŸŸï¼ˆ3x3ï¼‰ï¼Œç¢ºä¿ç©å®¶å¯ä»¥æ¥è¿‘
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const ny = pos.y + dy;
                        const nx = pos.x + dx;
                        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                            if (maze[ny][nx] === 1) maze[ny][nx] = 0; // ç§»é™¤ç‰†å£
                        }
                    }
                }
                // æ”¾ç½®èƒ½é‡è±†
                maze[pos.y][pos.x] = 3;
            });

            console.log('Maze generated successfully');
            return maze;
        }
        
        // åˆå§‹åŒ–éŠæˆ²
        function initGame(data) {
            gameState = data;
            
            document.getElementById('lobbyScreen').classList.remove('active');
            document.getElementById('gameScreen').classList.add('active');
            
            // æ›´æ–°ç©å®¶è³‡è¨Šé¢æ¿
            updateInfoPanel(data.players);
            
            // é–‹å§‹éŠæˆ²å¾ªç’°
            gameLoop();

            // ç›£è½éµç›¤
            setupKeyboardControls();

            // ç›£è½è§¸æ§ï¼ˆç§»å‹•ç«¯ï¼‰
            setupTouchControls();
        }
        
        // æ›´æ–°ç©å®¶è³‡è¨Šé¢æ¿
        function updateInfoPanel(players) {
            const panel = document.getElementById('gameInfoPanel');
            panel.innerHTML = '';

            Object.entries(players).forEach(([id, player]) => {
                const div = document.createElement('div');
                div.className = 'player-info';
                div.style.background = `linear-gradient(135deg, ${player.color} 0%, ${player.color}CC 100%)`;
                div.innerHTML = `
                    <div style="font-size: 0.85em;">${player.name}${id === currentPlayerId ? ' ' + t('you') : ''}</div>
                    <div>${t('score')}: <span id="score-${id}">${player.score || 0}</span></div>
                `;
                panel.appendChild(div);
            });
        }
        
        /**
         * è¨­å®šéµç›¤æ§åˆ¶
         *
         * æ”¹é€²é»ï¼š
         * 1. åŠ å…¥æ›´å¥½çš„éŒ¯èª¤è™•ç†
         * 2. é˜²æ­¢é‡è¤‡ç›£è½
         * 3. åŠ å…¥è©³ç´°æ—¥èªŒ
         */
        let keyboardListenerAdded = false; // é˜²æ­¢é‡è¤‡æ·»åŠ ç›£è½å™¨

        function setupKeyboardControls() {
            if (keyboardListenerAdded) {
                console.log('Keyboard controls already set up');
                return;
            }

            let lastMoveTime = 0;
            const moveDelay = 120; // ç§»å‹•å»¶é²ï¼ˆæ¯«ç§’ï¼‰

            document.addEventListener('keydown', async (e) => {
                if (!gameState || Date.now() - lastMoveTime < moveDelay) return;

                if (!database || !currentRoomId || !currentPlayerId) {
                    console.warn('Cannot move: missing database, room, or player ID');
                    return;
                }

                try {
                    const playerRef = database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`);
                    const snapshot = await playerRef.once('value');
                    const player = snapshot.val();

                    if (!player) {
                        console.warn('Player data not found');
                        return;
                    }
                
                let newX = player.x;
                let newY = player.y;
                
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    newY--;
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    newY++;
                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    newX--;
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    newX++;
                } else {
                    return;
                }
                
                    e.preventDefault();

                    // æª¢æŸ¥é‚Šç•Œå’Œç¢°æ’
                    if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                        if (gameState.maze[newY][newX] !== 1) {
                            lastMoveTime = Date.now();

                            const updates = {
                                x: newX,
                                y: newY
                            };

                            // æª¢æŸ¥æ˜¯å¦åƒåˆ°è±†å­
                            if (gameState.maze[newY][newX] === 2) {
                                updates.score = (player.score || 0) + 10;
                                await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                soundEatDot(); // ğŸ”Š åƒè±†å­éŸ³æ•ˆ
                            } else if (gameState.maze[newY][newX] === 3) {
                                // åƒåˆ°èƒ½é‡è±†ï¼šåŠ åˆ† + é€²å…¥ power mode
                                updates.score = (player.score || 0) + 50;
                                updates.powerMode = true;
                                updates.powerEndTime = Date.now() + 15000; // 15ç§’ power mode
                                await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                soundEatPowerPellet(); // ğŸ”Š åƒèƒ½é‡è±†éŸ³æ•ˆ
                                setTimeout(() => soundPowerMode(), 320); // ğŸ”Š è®Šèº«éŸ³æ•ˆï¼ˆå»¶é²æ’­æ”¾ï¼‰
                            }

                            await playerRef.update(updates);

                            // æª¢æŸ¥ç¢°æ’ï¼ˆç§»å‹•å¾Œï¼‰
                            checkCollision(newX, newY);
                        }
                    }
                } catch (error) {
                    console.error('Error handling keyboard input:', error);
                }
            });

            keyboardListenerAdded = true;
            console.log('Keyboard controls set up successfully');
        }

        /**
         * ğŸ® è¨­ç½®è™›æ“¬æ–æ¡¿æ§åˆ¶ï¼ˆç§»å‹•ç«¯ï¼‰
         *
         * åŠŸèƒ½ï¼š
         * - è§¸æ§è™›æ“¬æ–æ¡¿ç§»å‹•ç©å®¶
         * - è¦–è¦ºå›é¥‹ï¼ˆæ–æ¡¿ç§»å‹•ï¼‰
         * - èˆ‡éµç›¤æ§åˆ¶å…±ç”¨ç§»å‹•å»¶é²
         *
         * @returns {void}
         */
        function setupTouchControls() {
            const joystick = document.getElementById('virtualJoystick');
            const stick = document.getElementById('joystickStick');

            if (!joystick || !stick) {
                console.warn('Virtual joystick elements not found');
                return;
            }

            let touchStartTime = 0;
            const touchMoveDelay = 120; // èˆ‡éµç›¤ç§»å‹•å»¶é²ç›¸åŒ
            let lastTouchMoveTime = 0;
            let touchActive = false;
            let moveInterval = null;

            // è§¸æ§é–‹å§‹
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchActive = true;
                touchStartTime = Date.now();
                stick.classList.add('active');
                console.log('Touch started');
            }, { passive: false });

            // è§¸æ§ç§»å‹•
            joystick.addEventListener('touchmove', async (e) => {
                e.preventDefault();
                if (!touchActive || !gameState) return;

                const now = Date.now();
                if (now - lastTouchMoveTime < touchMoveDelay) return;

                try {
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    // è¨ˆç®—è§¸æ§é»ç›¸å°æ–¼ä¸­å¿ƒçš„åç§»
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;

                    // è¨ˆç®—è·é›¢å’Œè§’åº¦
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20; // æ–æ¡¿ç§»å‹•æœ€å¤§è·é›¢

                    // é™åˆ¶æ–æ¡¿ç§»å‹•ç¯„åœ
                    const limitedDistance = Math.min(distance, maxDistance);
                    const angle = Math.atan2(deltaY, deltaX);

                    // æ›´æ–°æ–æ¡¿è¦–è¦ºä½ç½®
                    const stickX = Math.cos(angle) * limitedDistance;
                    const stickY = Math.sin(angle) * limitedDistance;
                    stick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;

                    // åˆ¤æ–·ä¸»è¦ç§»å‹•æ–¹å‘ï¼ˆéœ€è¦è¶³å¤ çš„åç§»é‡æ‰è§¸ç™¼ç§»å‹•ï¼‰
                    const threshold = 15; // è§¸ç™¼ç§»å‹•çš„æœ€å°è·é›¢
                    if (distance < threshold) return;

                    let direction = null;
                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);

                    // é¸æ“‡ä¸»è¦æ–¹å‘ï¼ˆX æˆ– Y è»¸ï¼‰
                    if (absX > absY) {
                        direction = deltaX > 0 ? 'right' : 'left';
                    } else {
                        direction = deltaY > 0 ? 'down' : 'up';
                    }

                    // åŸ·è¡Œç§»å‹•
                    if (direction && database && currentRoomId && currentPlayerId) {
                        const playerRef = database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`);
                        const snapshot = await playerRef.once('value');
                        const player = snapshot.val();

                        if (!player) {
                            console.warn('Player data not found');
                            return;
                        }

                        let newX = player.x;
                        let newY = player.y;

                        switch (direction) {
                            case 'up': newY--; break;
                            case 'down': newY++; break;
                            case 'left': newX--; break;
                            case 'right': newX++; break;
                        }

                        // æª¢æŸ¥é‚Šç•Œå’Œç¢°æ’
                        if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                            if (gameState.maze[newY][newX] !== 1) {
                                lastTouchMoveTime = now;

                                const updates = {
                                    x: newX,
                                    y: newY
                                };

                                // æª¢æŸ¥æ˜¯å¦åƒåˆ°è±†å­
                                if (gameState.maze[newY][newX] === 2) {
                                    updates.score = (player.score || 0) + 10;
                                    await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                    soundEatDot(); // ğŸ”Š åƒè±†å­éŸ³æ•ˆ
                                } else if (gameState.maze[newY][newX] === 3) {
                                    // åƒåˆ°èƒ½é‡è±†ï¼šåŠ åˆ† + é€²å…¥ power mode
                                    updates.score = (player.score || 0) + 50;
                                    updates.powerMode = true;
                                    updates.powerEndTime = Date.now() + 15000; // 15ç§’ power mode
                                    await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                    soundEatPowerPellet(); // ğŸ”Š åƒèƒ½é‡è±†éŸ³æ•ˆ
                                    setTimeout(() => soundPowerMode(), 320); // ğŸ”Š è®Šèº«éŸ³æ•ˆï¼ˆå»¶é²æ’­æ”¾ï¼‰
                                }

                                await playerRef.update(updates);

                                // æª¢æŸ¥ç¢°æ’ï¼ˆç§»å‹•å¾Œï¼‰
                                checkCollision(newX, newY);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error handling touch input:', error);
                }
            }, { passive: false });

            // è§¸æ§çµæŸ
            const handleTouchEnd = (e) => {
                e.preventDefault();
                touchActive = false;
                stick.classList.remove('active');
                // é‡ç½®æ–æ¡¿ä½ç½®ï¼ˆå›åˆ°ä¸­å¿ƒï¼‰
                stick.style.transform = 'translate(-50%, -50%)';

                if (moveInterval) {
                    clearInterval(moveInterval);
                    moveInterval = null;
                }
                console.log('Touch ended');
            };

            joystick.addEventListener('touchend', handleTouchEnd, { passive: false });
            joystick.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            console.log('Touch controls set up successfully');
        }

        // ğŸ”§ ç¢°æ’å†·å»è¿½è¹¤ï¼ˆé¿å…é‡è¤‡ç¢°æ’ï¼‰
        let lastCollisionTime = {};
        const COLLISION_COOLDOWN = 1000; // 1ç§’ç¢°æ’å†·å»

        /**
         * æª¢æŸ¥ç©å®¶ç¢°æ’ä¸¦åŸ·è¡Œæ¶åˆ†
         * @param {number} myX - è‡ªå·±çš„ X åº§æ¨™
         * @param {number} myY - è‡ªå·±çš„ Y åº§æ¨™
         *
         * æ”¹é€²é»ï¼š
         * 1. åŠ å…¥ç¢°æ’å†·å»ï¼ˆé¿å…çŸ­æ™‚é–“å…§é‡è¤‡ç¢°æ’ï¼‰
         * 2. åªè®“ ID è¼ƒå°çš„ç©å®¶è™•ç†ç¢°æ’ï¼ˆé¿å…é›™æ–¹åŒæ™‚è™•ç†å°è‡´é›™å€æ‰£åˆ†ï¼‰
         * 3. æ›´å¥½çš„éŒ¯èª¤è™•ç†
         */
        async function checkCollision(myX, myY) {
            if (!gameState || !gameState.players || !currentPlayerId || !database) return;

            const myPlayer = gameState.players[currentPlayerId];
            if (!myPlayer) return;

            const now = Date.now();
            const myPowerMode = myPlayer.powerMode && myPlayer.powerEndTime && now < myPlayer.powerEndTime;

            // éæ­·æ‰€æœ‰å…¶ä»–ç©å®¶
            for (const [otherId, otherPlayer] of Object.entries(gameState.players)) {
                if (otherId === currentPlayerId) continue; // è·³éè‡ªå·±

                // ğŸ”§ æª¢æŸ¥ç¢°æ’å†·å»ï¼ˆé¿å…çŸ­æ™‚é–“å…§é‡è¤‡è™•ç†ï¼‰
                const collisionKey = [currentPlayerId, otherId].sort().join('-');
                if (lastCollisionTime[collisionKey] && now - lastCollisionTime[collisionKey] < COLLISION_COOLDOWN) {
                    continue; // é‚„åœ¨å†·å»ä¸­ï¼Œè·³é
                }

                // æª¢æŸ¥ä½ç½®æ˜¯å¦é‡ç–Šï¼ˆåŒä¸€æ ¼æˆ–ç›¸é„°ï¼‰
                const distance = Math.abs(myX - otherPlayer.x) + Math.abs(myY - otherPlayer.y);
                if (distance <= 1) { // ç¢°æ’ï¼
                    // ğŸ”§ åªè®“ ID è¼ƒå°çš„ç©å®¶è™•ç†ç¢°æ’ï¼ˆé¿å…é›™æ–¹åŒæ™‚è™•ç†ï¼‰
                    if (currentPlayerId > otherId) {
                        console.log('Collision detected but handled by other player');
                        continue;
                    }
                    const otherPowerMode = otherPlayer.powerMode && otherPlayer.powerEndTime && now < otherPlayer.powerEndTime;

                    let myScoreChange = 0;
                    let otherScoreChange = 0;

                    // åˆ¤æ–·æ¶åˆ†è¦å‰‡
                    if (myPowerMode && !otherPowerMode) {
                        // æˆ‘åœ¨ power modeï¼Œå°æ–¹ä¸åœ¨ï¼šæ¶ 50%
                        const stolen = Math.floor((otherPlayer.score || 0) * 0.5);
                        myScoreChange = stolen;
                        otherScoreChange = -stolen;
                        showScoreFloating(myX, myY, `+${stolen}`, '#00FF00');
                        showScoreFloating(otherPlayer.x, otherPlayer.y, `-${stolen}`, '#FF0000');
                        soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        if (stolen > 0) soundScore(); // ğŸ”Š å¾—åˆ†éŸ³æ•ˆ
                    } else if (!myPowerMode && otherPowerMode) {
                        // å°æ–¹åœ¨ power modeï¼Œæˆ‘ä¸åœ¨ï¼šè¢«æ¶ 50%
                        const stolen = Math.floor((myPlayer.score || 0) * 0.5);
                        myScoreChange = -stolen;
                        otherScoreChange = stolen;
                        showScoreFloating(myX, myY, `-${stolen}`, '#FF0000');
                        soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                    } else if (myPowerMode && otherPowerMode) {
                        // é›™æ–¹éƒ½åœ¨ power modeï¼šå½ˆé–‹ï¼Œä¸æ¶åˆ†
                        console.log('Both in power mode - bounce!');
                        soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        return;
                    } else {
                        // é›™æ–¹éƒ½ä¸åœ¨ power modeï¼šåˆ†æ•¸é«˜è€…æ¶ 20%
                        const myScore = myPlayer.score || 0;
                        const otherScore = otherPlayer.score || 0;

                        if (myScore > otherScore) {
                            const stolen = Math.floor(otherScore * 0.2);
                            myScoreChange = stolen;
                            otherScoreChange = -stolen;
                            showScoreFloating(myX, myY, `+${stolen}`, '#00FF00');
                            showScoreFloating(otherPlayer.x, otherPlayer.y, `-${stolen}`, '#FF0000');
                            soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                            if (stolen > 0) soundScore(); // ğŸ”Š å¾—åˆ†éŸ³æ•ˆ
                        } else if (otherScore > myScore) {
                            const stolen = Math.floor(myScore * 0.2);
                            myScoreChange = -stolen;
                            otherScoreChange = stolen;
                            showScoreFloating(myX, myY, `-${stolen}`, '#FF0000');
                            soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        } else {
                            // åˆ†æ•¸ç›¸ç­‰ï¼šåªæœ‰ç¢°æ’éŸ³æ•ˆ
                            soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        }
                    }

                    // ğŸ”§ è¨˜éŒ„ç¢°æ’æ™‚é–“ï¼ˆå†·å»ï¼‰
                    lastCollisionTime[collisionKey] = now;

                    // æ›´æ–°åˆ†æ•¸ï¼ˆç¢ºä¿ä¸æœƒè®Šæˆè² æ•¸ï¼‰
                    try {
                        if (myScoreChange !== 0) {
                            const newScore = Math.max(0, (myPlayer.score || 0) + myScoreChange);
                            await database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}/score`).set(newScore);
                        }
                        if (otherScoreChange !== 0) {
                            const newOtherScore = Math.max(0, (otherPlayer.score || 0) + otherScoreChange);
                            await database.ref(`rooms/${currentRoomId}/players/${otherId}/score`).set(newOtherScore);
                        }
                        console.log(`Collision processed: ${currentPlayerId} vs ${otherId}, scores: ${myScoreChange}, ${otherScoreChange}`);
                    } catch (error) {
                        console.error('Error updating scores after collision:', error);
                    }

                    break; // åªè™•ç†ç¬¬ä¸€å€‹ç¢°æ’
                }
            }
        }

        // åˆ†æ•¸é£„å­—å‹•ç•«æ•¸æ“š
        let floatingTexts = [];

        // æ·»åŠ åˆ†æ•¸é£„å­—
        function showScoreFloating(x, y, text, color) {
            floatingTexts.push({
                x: x * CELL_SIZE + CELL_SIZE / 2,
                y: y * CELL_SIZE - 20,
                text: text,
                color: color,
                alpha: 1.0,
                createdAt: Date.now()
            });
        }

        // éŸ³æ•ˆæ§åˆ¶è®Šé‡
        let lastTickSecond = -1;
        let powerWarningPlayed = {}; // è¿½è¹¤æ¯å€‹ç©å®¶æ˜¯å¦å·²æ’­æ”¾è­¦å‘ŠéŸ³

        // æ›´æ–°éŠæˆ²ç‹€æ…‹
        function updateGameState(data) {
            gameState = data;
            
            // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
            if (data.players) {
                Object.entries(data.players).forEach(([id, player]) => {
                    const scoreEl = document.getElementById(`score-${id}`);
                    if (scoreEl) {
                        scoreEl.textContent = player.score || 0;
                    }
                });
            }
        }
        
        // éŠæˆ²å¾ªç’°
        function gameLoop() {
            if (!gameState) return;

            const now = Date.now();

            // è¨ˆç®—éŠæˆ²å‰©é¤˜æ™‚é–“ï¼ˆ3åˆ†é˜ = 180ç§’ï¼‰
            const GAME_DURATION = 180 * 1000; // 3åˆ†é˜ï¼ˆæ¯«ç§’ï¼‰
            const elapsed = now - (gameState.startedAt || now);
            const remaining = Math.max(0, GAME_DURATION - elapsed);
            const remainingSeconds = Math.ceil(remaining / 1000);
            const isLastThirty = remainingSeconds <= 30 && remainingSeconds > 0;

            // æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ
            if (remaining === 0 && gameState.status === 'playing' && isHost && database) {
                // æ™‚é–“åˆ°ï¼çµæŸéŠæˆ²
                database.ref(`rooms/${currentRoomId}`).update({
                    status: 'finished',
                    finishedAt: now
                });
                showGameResults();
                return;
            }

            // ğŸ”Š æœ€å¾Œ30ç§’å€’æ•¸éŸ³æ•ˆï¼ˆæ¯ç§’ä¸€æ¬¡ï¼‰
            if (isLastThirty && remainingSeconds !== lastTickSecond) {
                lastTickSecond = remainingSeconds;
                soundTick();
            }

            // ğŸ”§ æª¢æŸ¥ä¸¦æ¸…é™¤éæœŸçš„ power modeï¼ˆåªæ¸…é™¤è‡ªå·±çš„ç‹€æ…‹ï¼Œé¿å…å¤šæ¬¡æ›´æ–°ï¼‰
            if (gameState.players && database) {
                Object.entries(gameState.players).forEach(([id, player]) => {
                    if (player.powerMode && player.powerEndTime && now >= player.powerEndTime) {
                        // ğŸ”§ åªæ¸…é™¤è‡ªå·±çš„ power mode ç‹€æ…‹ï¼ˆé¿å…æ‰€æœ‰ç©å®¶éƒ½å»æ¸…é™¤å°è‡´å¤šæ¬¡æ›´æ–°ï¼‰
                        if (id === currentPlayerId) {
                            database.ref(`rooms/${currentRoomId}/players/${id}`).update({
                                powerMode: false,
                                powerEndTime: null
                            }).catch(error => {
                                console.error('Error clearing power mode:', error);
                            });
                            console.log('Power mode expired, clearing status');
                        }
                        // æ¸…é™¤è­¦å‘ŠéŸ³æ¨™è¨˜
                        delete powerWarningPlayed[id];
                    } else if (player.powerMode && player.powerEndTime) {
                        // ğŸ”Š æª¢æŸ¥æ˜¯å¦éœ€è¦æ’­æ”¾è­¦å‘ŠéŸ³ï¼ˆæœ€å¾Œ5ç§’ï¼Œä¸”è©²ç©å®¶æ˜¯è‡ªå·±ï¼‰
                        const timeLeft = (player.powerEndTime - now) / 1000;
                        if (timeLeft <= 5 && timeLeft > 4.5 && id === currentPlayerId && !powerWarningPlayed[id]) {
                            soundPowerWarning();
                            powerWarningPlayed[id] = true;
                        }
                    }
                });
            }

            // æ¸…ç©ºç•«å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æœ€å¾Œ30ç§’èƒŒæ™¯é–ƒçˆè­¦å‘Š
            if (isLastThirty && Math.floor(now / 500) % 2 === 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // ç¹ªè£½è¿·å®®
            if (gameState.maze) {
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (gameState.maze[y][x] === 1) {
                            ctx.fillStyle = '#0000FF';
                            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                            ctx.strokeStyle = '#4169E1';
                            ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        } else if (gameState.maze[y][x] === 2) {
                            ctx.fillStyle = '#FFF';
                            ctx.beginPath();
                            ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 3, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (gameState.maze[y][x] === 3) {
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#FFA500';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // ç¹ªè£½ç©å®¶
            if (gameState.players) {
                const now = Date.now();
                Object.entries(gameState.players).forEach(([id, player]) => {
                    const centerX = player.x * CELL_SIZE + CELL_SIZE / 2;
                    const centerY = player.y * CELL_SIZE + CELL_SIZE / 2;

                    // æª¢æŸ¥æ˜¯å¦åœ¨ power mode
                    const isPowerMode = player.powerMode && player.powerEndTime && now < player.powerEndTime;
                    const timeRemaining = isPowerMode ? (player.powerEndTime - now) / 1000 : 0;
                    const isWarning = timeRemaining > 0 && timeRemaining <= 5; // æœ€å¾Œ5ç§’è­¦å‘Š
                    const shouldFlash = isWarning && Math.floor(now / 200) % 2 === 0; // 200msé–ƒçˆ

                    // Power mode è¦–è¦ºæ•ˆæœ
                    if (isPowerMode && !shouldFlash) {
                        const baseRadius = CELL_SIZE / 2 - 2;
                        const powerRadius = baseRadius * 1.2; // è®Šå¤§ 1.2 å€

                        // å½©è™¹å…‰æšˆæ•ˆæœï¼ˆå¤šå±¤æ¼¸è®Šåœ“ï¼‰
                        const hue = (now / 50) % 360; // å½©è™¹è‰²ç›¸æ—‹è½‰

                        // å¤–å±¤å…‰æšˆ
                        for (let i = 3; i >= 0; i--) {
                            const gradient = ctx.createRadialGradient(
                                centerX, centerY, powerRadius,
                                centerX, centerY, powerRadius + 6 + i * 2
                            );
                            gradient.addColorStop(0, `hsla(${(hue + i * 30) % 360}, 100%, 50%, 0.4)`);
                            gradient.addColorStop(1, `hsla(${(hue + i * 30) % 360}, 100%, 50%, 0)`);

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, powerRadius + 8 + i * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // ç©å®¶æœ¬é«”ï¼ˆæ›´å¤§ï¼‰
                        ctx.fillStyle = player.color;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, powerRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // çœ¼ç›ï¼ˆæ”¾å¤§ï¼‰
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(centerX - 4, centerY - 3, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(centerX + 4, centerY - 3, 2.5, 0, Math.PI * 2);
                        ctx.fill();

                        // èƒ½é‡è±†å€’æ•¸æç¤ºï¼ˆæœ€å¾Œ5ç§’ï¼‰
                        if (isWarning) {
                            ctx.fillStyle = '#FF0000';
                            ctx.font = 'bold 10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(Math.ceil(timeRemaining), centerX, centerY + powerRadius + 15);
                        }
                    } else {
                        // æ™®é€šæ¨¡å¼æˆ–é–ƒçˆæ™‚é¡¯ç¤ºæ™®é€šå¤–è§€
                        const normalRadius = CELL_SIZE / 2 - 2;

                        ctx.fillStyle = player.color;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, normalRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // çœ¼ç›
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(centerX - 3, centerY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(centerX + 3, centerY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // åå­—ï¼ˆå§‹çµ‚é¡¯ç¤ºï¼‰
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeText(player.name, centerX, player.y * CELL_SIZE - 5);
                    ctx.fillText(player.name, centerX, player.y * CELL_SIZE - 5);
                });
            }

            // ç¹ªè£½è¨ˆæ™‚å™¨ï¼ˆé ‚éƒ¨ä¸­å¤®ï¼‰
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            const timeText = `â±ï¸ ${minutes}:${seconds.toString().padStart(2, '0')}`;

            ctx.save();
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';

            // æœ€å¾Œ30ç§’ç´…è‰²é–ƒçˆ
            if (isLastThirty) {
                const flashIntensity = Math.floor(now / 250) % 2 === 0 ? 1.0 : 0.6;
                ctx.fillStyle = `rgba(255, 0, 0, ${flashIntensity})`;
                ctx.strokeStyle = '#FFF';
            } else {
                ctx.fillStyle = '#FFF';
                ctx.strokeStyle = '#000';
            }

            ctx.lineWidth = 4;
            ctx.strokeText(timeText, canvas.width / 2, 40);
            ctx.fillText(timeText, canvas.width / 2, 40);
            ctx.restore();

            // æœ€å¾Œ30ç§’è­¦å‘Šæ–‡å­—
            if (isLastThirty) {
                ctx.save();
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#FF0000';
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 3;
                const warningText = t('warning30sec');
                ctx.strokeText(warningText, canvas.width / 2, 70);
                ctx.fillText(warningText, canvas.width / 2, 70);
                ctx.restore();
            }

            // ğŸ† ç¹ªè£½å³æ™‚æ’åï¼ˆå³ä¸Šè§’ï¼‰
            if (gameState.players) {
                // è¨ˆç®—æ’å
                const rankings = Object.entries(gameState.players)
                    .map(([id, player]) => ({
                        id,
                        name: player.name,
                        color: player.color,
                        score: player.score || 0
                    }))
                    .sort((a, b) => b.score - a.score);

                // æ‰¾åˆ°è‡ªå·±çš„æ’å
                const myRank = rankings.findIndex(p => p.id === currentPlayerId);
                const isInTop3 = myRank < 3;

                // èƒŒæ™¯æ¡†
                const boxX = canvas.width - 220;
                const boxY = 95;
                const boxWidth = 210;
                const boxHeight = isInTop3 ? 145 : 200; // å¦‚æœä¸åœ¨å‰3ï¼Œå¤šé¡¯ç¤ºè‡ªå·±

                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // æ¨™é¡Œ
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFD700';
                ctx.fillText(t('ranking'), boxX + 10, boxY + 28);

                // é¡¯ç¤ºå‰3å
                let yPos = boxY + 60;
                const topPlayers = rankings.slice(0, 3);

                topPlayers.forEach((player, index) => {
                    const isMe = player.id === currentPlayerId;
                    const rank = index + 1;

                    // é«˜äº®è‡ªå·±
                    if (isMe) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                        ctx.fillRect(boxX + 5, yPos - 20, boxWidth - 10, 28);
                    }

                    // æ’å
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : '#CD7F32';
                    ctx.fillText(`#${rank}`, boxX + 15, yPos);

                    // ç©å®¶é¡è‰²é»
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.arc(boxX + 50, yPos - 5, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // ç©å®¶åå­—
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#FFF';
                    ctx.textAlign = 'left';
                    const displayName = player.name.length > 8 ? player.name.substring(0, 7) + '...' : player.name;
                    ctx.fillText(displayName + (isMe ? ' ' + t('you') : ''), boxX + 62, yPos);

                    // åˆ†æ•¸
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(player.score.toString(), boxX + boxWidth - 15, yPos);

                    yPos += 30;
                });

                // å¦‚æœè‡ªå·±ä¸åœ¨å‰3ï¼Œé¡¯ç¤ºåˆ†éš”ç·š + è‡ªå·±çš„æ’å
                if (!isInTop3 && myRank >= 0) {
                    // åˆ†éš”ç·š
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(boxX + 10, yPos + 5);
                    ctx.lineTo(boxX + boxWidth - 10, yPos + 5);
                    ctx.stroke();

                    yPos += 25;

                    const myPlayer = rankings[myRank];

                    // é«˜äº®èƒŒæ™¯
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.fillRect(boxX + 5, yPos - 20, boxWidth - 10, 28);

                    // æˆ‘çš„æ’å
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(`#${myRank + 1}`, boxX + 15, yPos);

                    // ç©å®¶é¡è‰²é»
                    ctx.fillStyle = myPlayer.color;
                    ctx.beginPath();
                    ctx.arc(boxX + 50, yPos - 5, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // ç©å®¶åå­—
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#FFF';
                    ctx.textAlign = 'left';
                    const displayName = myPlayer.name.length > 8 ? myPlayer.name.substring(0, 7) + '...' : myPlayer.name;
                    ctx.fillText(displayName + ' ' + t('you'), boxX + 62, yPos);

                    // åˆ†æ•¸
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(myPlayer.score.toString(), boxX + boxWidth - 15, yPos);
                }

                ctx.restore();
            }

            // ç¹ªè£½åˆ†æ•¸é£„å­—å‹•ç•«
            floatingTexts = floatingTexts.filter(ft => {
                const elapsed = now - ft.createdAt;
                if (elapsed > 1500) return false; // 1.5ç§’å¾Œç§»é™¤

                // è¨ˆç®—å‹•ç•«åƒæ•¸
                ft.y -= 0.5; // å‘ä¸Šé£„
                ft.alpha = Math.max(0, 1 - elapsed / 1500); // æ·¡å‡º

                // ç¹ªè£½
                ctx.save();
                ctx.globalAlpha = ft.alpha;
                ctx.fillStyle = ft.color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(ft.text, ft.x, ft.y);
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();

                return true; // ä¿ç•™
            });

            requestAnimationFrame(gameLoop);
        }
        
        /**
         * é¡¯ç¤ºéŠæˆ²çµç®—ç•«é¢
         *
         * æ”¹é€²é»ï¼š
         * 1. åŠ å…¥æˆ¿é–“è‡ªå‹•æ¸…ç†ï¼ˆ20ç§’å¾Œåˆªé™¤æˆ¿é–“æ•¸æ“šï¼‰
         * 2. æ›´å¥½çš„éŒ¯èª¤è™•ç†
         */
        function showGameResults() {
            if (!gameState || !gameState.players) return;

            // ğŸ”Š éŠæˆ²çµæŸéŸ³æ•ˆ
            soundGameEnd();

            // ä¿å­˜ç©å®¶æ•¸æ“šå¾Œåœæ­¢éŠæˆ²å¾ªç’°
            const finalPlayers = gameState.players;
            const roomIdToClean = currentRoomId; // ä¿å­˜æˆ¿é–“ ID
            gameState = null;

            // è¨ˆç®—æ’å
            const rankings = Object.entries(finalPlayers || {})
                .map(([id, player]) => ({
                    id,
                    name: player.name,
                    color: player.color,
                    score: player.score || 0
                }))
                .sort((a, b) => b.score - a.score);

            // æ¸…ç©ºç•«å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç¹ªè£½æ¨™é¡Œ
            ctx.save();
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 5;
            ctx.strokeText(t('gameOver'), canvas.width / 2, 80);
            ctx.fillText(t('gameOver'), canvas.width / 2, 80);
            ctx.restore();

            // ç¹ªè£½æ’å
            let startY = 150;
            const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];

            rankings.forEach((player, index) => {
                const isMe = player.id === currentPlayerId;
                const y = startY + index * 60;

                // èƒŒæ™¯ï¼ˆè‡ªå·±çš„æ’åé«˜äº®ï¼‰
                if (isMe) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.fillRect(canvas.width / 2 - 300, y - 35, 600, 55);
                }

                // æ’åæ•¸å­—æˆ–çç‰Œ
                ctx.save();
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFF';

                const rankText = index < 3 ? medals[index] : `#${index + 1}`;
                ctx.fillText(rankText, canvas.width / 2 - 200, y);

                // ç©å®¶é¡è‰²é»
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(canvas.width / 2 - 160, y - 10, 15, 0, Math.PI * 2);
                ctx.fill();

                // ç©å®¶åå­—
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFF';
                const nameText = `${player.name}${isMe ? ' ' + t('you') : ''}`;
                ctx.fillText(nameText, canvas.width / 2 - 130, y);

                // åˆ†æ•¸
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFD700';
                ctx.fillText(`${player.score} ${t('points')}`, canvas.width / 2 + 250, y);

                ctx.restore();
            });

            // ç¹ªè£½æç¤ºæ–‡å­—
            ctx.save();
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#AAA';
            ctx.fillText(t('autoReturn'), canvas.width / 2, canvas.height - 50);
            ctx.restore();

            // 15ç§’å¾Œè‡ªå‹•è¿”å›å¤§å»³
            setTimeout(() => {
                window.location.reload();
            }, 15000);

            // ğŸ”§ 20ç§’å¾Œè‡ªå‹•æ¸…ç†æˆ¿é–“æ•¸æ“šï¼ˆåªæœ‰ Host åŸ·è¡Œï¼‰
            if (isHost && database && roomIdToClean) {
                setTimeout(async () => {
                    try {
                        await database.ref(`rooms/${roomIdToClean}`).remove();
                        console.log(`Room ${roomIdToClean} cleaned up successfully`);
                    } catch (error) {
                        console.error('Error cleaning up room:', error);
                    }
                }, 20000); // 20ç§’å¾Œæ¸…ç†ï¼ˆçµ¦æ‰€æœ‰ç©å®¶è¶³å¤ æ™‚é–“çœ‹çµç®—ï¼‰
            }
        }

        // é›¢é–‹æˆ¿é–“
        async function leaveRoom() {
            if (currentRoomId && currentPlayerId && database) {
                const playerRef = database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`);
                await playerRef.remove();
            }
            window.location.reload();
        }
        
        // é é¢è¼‰å…¥å¾Œè¨­å®šäº‹ä»¶ç›£è½å™¨
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up event listeners');
            
            const btnShowCreate = document.getElementById('btnShowCreate');
            const btnShowJoin = document.getElementById('btnShowJoin');
            const btnCreateRoom = document.getElementById('btnCreateRoom');
            const btnJoinRoom = document.getElementById('btnJoinRoom');
            
            console.log('Button elements:', {
                btnShowCreate: btnShowCreate ? 'Found' : 'Not found',
                btnShowJoin: btnShowJoin ? 'Found' : 'Not found',
                btnCreateRoom: btnCreateRoom ? 'Found' : 'Not found',
                btnJoinRoom: btnJoinRoom ? 'Found' : 'Not found'
            });
            
            btnShowCreate.addEventListener('click', function() {
                console.log('btnShowCreate clicked');
                showCreateRoom();
            });
            btnShowJoin.addEventListener('click', function() {
                console.log('btnShowJoin clicked');
                showJoinRoom();
            });
            btnCreateRoom.addEventListener('click', function() {
                console.log('btnCreateRoom clicked');
                createRoom();
            });
            btnJoinRoom.addEventListener('click', function() {
                console.log('btnJoinRoom clicked');
                joinRoom();
            });
            document.getElementById('btnBackFromCreate').addEventListener('click', backToMenu);
            document.getElementById('btnBackFromJoin').addEventListener('click', backToMenu);
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('btnLeaveLobby').addEventListener('click', leaveRoom);
            document.getElementById('btnLeaveGame').addEventListener('click', leaveRoom);

            // éŸ³æ•ˆé–‹é—œ
            document.getElementById('btnToggleSound').addEventListener('click', function() {
                isSoundEnabled = !isSoundEnabled;
                updateSoundButtonText();
                // æ¸¬è©¦éŸ³æ•ˆ
                if (isSoundEnabled) soundEatDot();
            });

            // èªè¨€åˆ‡æ›æŒ‰éˆ•
            document.getElementById('languageToggle').addEventListener('click', function() {
                toggleLanguage();
            });

            // åˆå§‹åŒ–èªè¨€è¨­å®š
            updateUILanguage();

            // Enter éµæ”¯æŒ
            document.getElementById('hostName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createRoom();
            });
            document.getElementById('playerName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            document.getElementById('roomCode').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            console.log('Event listeners set up successfully');
        });
    </script>
</body>
</html>