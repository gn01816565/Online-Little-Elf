<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç·šä¸Šå¤šäººå°ç²¾éˆéŠæˆ² (10äººç‰ˆ)</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="æ”¯æ´æœ€å¤š 10 äººåŒæ™‚éŠç©çš„ç·šä¸Šå¤šäºº Pac-Man éŠæˆ²ï¼Œå…·å‚™è™›æ“¬æ–æ¡¿ã€å³æ™‚æ’åã€èƒ½é‡è±†ç³»çµ±">
    <meta name="keywords" content="å°ç²¾éˆ,pacman,å¤šäººéŠæˆ²,ç·šä¸ŠéŠæˆ²,HTML5éŠæˆ²">
    <meta name="author" content="Claude Code AI Assistant">
    <meta name="theme-color" content="#764ba2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="å°ç²¾éˆ">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="å°ç²¾éˆ">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icon-16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon-192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
    <link rel="apple-touch-icon" sizes="120x120" href="icon-128.png">
    <link rel="apple-touch-icon" sizes="76x76" href="icon-72.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .menu-screen, .game-screen {
            display: none;
        }
        
        .menu-screen.active, .game-screen.active {
            display: block;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 400px;
            margin: 0 auto;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .input-group {
            margin: 20px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: bold;
        }
        
        .input-group input {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            outline: none;
        }
        
        .input-group input:focus {
            border-color: #764ba2;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .room-code {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }
        
        .room-code h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .room-code .code {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            letter-spacing: 5px;
            font-family: monospace;
        }
        
        .players-list {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .players-list h3 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .player-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .player-info {
            padding: 10px 15px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }
        
        canvas {
            display: block;
            background: #000;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin: 0 auto;
            max-width: 100%;
        }
        
        .game-controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .status-message {
            text-align: center;
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-message.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status-message.warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .back-button {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            margin-top: 10px;
        }

        .language-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .language-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .language-toggle:active {
            transform: translateY(0);
        }

        /* ğŸ® è™›æ“¬æ–æ¡¿æ¨£å¼ï¼ˆç§»å‹•ç«¯ï¼‰ */
        .virtual-joystick {
            display: none; /* é è¨­éš±è— */
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            z-index: 1000;
            touch-action: none; /* é˜²æ­¢è§¸æ§æ»¾å‹• */
            opacity: 0.85; /* åŠé€æ˜ï¼Œé¿å…é®æ“‹éŠæˆ²ç•«é¢ */
        }

        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.2) 100%);
            border: 3px solid rgba(102, 126, 234, 0.5);
            border-radius: 50%;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease-out;
        }

        .joystick-stick.active {
            background: radial-gradient(circle, #764ba2 0%, #667eea 100%);
            box-shadow: 0 3px 15px rgba(102, 126, 234, 0.6);
        }

        /* ğŸ“± ç§»å‹•ç«¯é©é… */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
                border-radius: 10px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            button {
                padding: 12px 24px;
                font-size: 1em;
            }

            .language-toggle {
                top: 10px;
                right: 10px;
                padding: 8px 16px;
                font-size: 0.9em;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }

            .virtual-joystick {
                display: block; /* ç§»å‹•ç«¯é¡¯ç¤ºè™›æ“¬æ–æ¡¿ */
                width: 120px;
                height: 120px;
                bottom: 20px;
                left: 20px;
            }

            .joystick-stick {
                width: 50px;
                height: 50px;
            }

            .info-panel {
                grid-template-columns: 1fr;
            }

            .player-info {
                font-size: 0.8em;
                padding: 8px 12px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em;
            }

            .container {
                padding: 10px;
            }

            button {
                padding: 10px 20px;
                font-size: 0.9em;
            }

            .virtual-joystick {
                width: 100px;
                height: 100px;
                bottom: 15px;
                left: 15px;
            }

            .joystick-stick {
                width: 40px;
                height: 40px;
            }

            .language-toggle {
                padding: 6px 12px;
                font-size: 0.8em;
            }
        }

        /* ğŸ–¥ï¸ æ¡Œé¢ç«¯éš±è—è™›æ“¬æ–æ¡¿ï¼Œé¡¯ç¤ºéµç›¤æç¤º */
        .keyboard-hint {
            display: block;
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .keyboard-hint {
                display: none; /* ç§»å‹•ç«¯éš±è—éµç›¤æç¤º */
            }
        }
    </style>
</head>
<body>
    <button class="language-toggle" id="languageToggle">
        <span id="langIcon">ğŸŒ</span>
        <span id="langText">English</span>
    </button>

    <div class="container">
        <h1 id="mainTitle">ğŸ® ç·šä¸Šå¤šäººå°ç²¾éˆ (æœ€å¤š10äºº) ğŸ®</h1>
        
        <!-- ä¸»é¸å–® -->
        <div id="menuScreen" class="menu-screen active">
            <div class="menu-buttons">
                <button id="btnShowCreate"><span id="textBtnCreate">ğŸ¯ å»ºç«‹éŠæˆ²æˆ¿é–“</span></button>
                <button id="btnShowJoin"><span id="textBtnJoin">ğŸšª åŠ å…¥éŠæˆ²æˆ¿é–“</span></button>
                <button id="btnSoloPractice" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);"><span id="textBtnSoloPractice">âš¡ å–®äººç·´ç¿’</span></button>
                <button id="btnHowToPlay" class="back-button"><span id="textBtnHowToPlay">â“ å¦‚ä½•éŠç©</span></button>
            </div>

            <div id="createRoomSection" style="display: none;">
                <div class="input-group">
                    <label id="labelHostName">ä½ çš„æš±ç¨±ï¼š</label>
                    <input type="text" id="hostName" data-placeholder-key="placeholderNickname" placeholder="è¼¸å…¥ä½ çš„æš±ç¨±" maxlength="15">
                </div>

                <!-- ğŸ¤– AI é…ç½®é¸é … -->
                <div class="input-group" style="margin-top: 20px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="enableAI" style="width: auto; margin-right: 10px;">
                        <span>ğŸ¤– åŠ å…¥ AI ç©å®¶</span>
                    </label>
                </div>

                <div id="aiConfigSection" style="display: none; margin-top: 15px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 10px;">
                    <div class="input-group">
                        <label>AI æ•¸é‡ï¼š<span id="aiCountValue">2</span></label>
                        <input type="range" id="aiCount" min="1" max="9" value="2" style="width: 100%;">
                    </div>

                    <div class="input-group">
                        <label>AI é›£åº¦ï¼š</label>
                        <select id="aiDifficulty" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #ddd; font-size: 1em;">
                            <option value="easy">ğŸŸ¢ ç°¡å–® (Easy)</option>
                            <option value="medium" selected>ğŸŸ¡ ä¸­ç­‰ (Medium)</option>
                            <option value="hard">ğŸ”´ å›°é›£ (Hard)</option>
                        </select>
                    </div>
                </div>

                <button id="btnCreateRoom"><span id="textBtnCreateRoom">å»ºç«‹æˆ¿é–“</span></button>
                <button class="back-button" id="btnBackFromCreate"><span id="textBtnBack1">è¿”å›</span></button>
            </div>

            <div id="joinRoomSection" style="display: none;">
                <div class="input-group">
                    <label id="labelPlayerName">ä½ çš„æš±ç¨±ï¼š</label>
                    <input type="text" id="playerName" data-placeholder-key="placeholderNickname" placeholder="è¼¸å…¥ä½ çš„æš±ç¨±" maxlength="15">
                </div>
                <div class="input-group">
                    <label id="labelRoomCode">æˆ¿é–“ä»£ç¢¼ï¼š</label>
                    <input type="text" id="roomCode" data-placeholder-key="placeholderRoomCode" placeholder="è¼¸å…¥6ä½æ•¸æˆ¿é–“ä»£ç¢¼" maxlength="6">
                </div>
                <button id="btnJoinRoom"><span id="textBtnJoinRoom">åŠ å…¥æˆ¿é–“</span></button>
                <button class="back-button" id="btnBackFromJoin"><span id="textBtnBack2">è¿”å›</span></button>
            </div>
        </div>
        
        <!-- ç­‰å¾…å®¤ -->
        <div id="lobbyScreen" class="menu-screen">
            <div class="room-code">
                <h3 id="textRoomCodeTitle">æˆ¿é–“ä»£ç¢¼</h3>
                <div class="code" id="displayRoomCode"></div>
                <p id="textShareCode" style="margin-top: 10px; color: #666;">åˆ†äº«æ­¤ä»£ç¢¼çµ¦æœ‹å‹åŠ å…¥éŠæˆ²</p>
            </div>

            <div class="players-list">
                <h3><span id="textPlayersJoined">å·²åŠ å…¥ç©å®¶</span> (<span id="playerCount">0</span>/10)</h3>
                <div id="playersList"></div>
            </div>

            <div class="status-message info">
                <span id="textWaitingMessage">ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥... (è‡³å°‘éœ€è¦2ä½ç©å®¶)</span>
            </div>

            <button id="startButton" disabled><span id="textBtnStart">é–‹å§‹éŠæˆ²</span></button>
            <button class="back-button" id="btnLeaveLobby"><span id="textBtnLeaveLobby">é›¢é–‹æˆ¿é–“</span></button>
        </div>
        
        <!-- éŠæˆ²ç•«é¢ -->
        <div id="gameScreen" class="game-screen">
            <div class="info-panel" id="gameInfoPanel"></div>

            <canvas id="gameCanvas" width="1000" height="800"></canvas>

            <div class="game-controls">
                <p id="textControls" style="margin-bottom: 10px; color: #666;">
                    ä½¿ç”¨æ–¹å‘éµ â†‘ â†“ â† â†’ æˆ– W A S D ç§»å‹•
                </p>
                <button id="btnToggleSound" style="margin-bottom: 10px;"><span id="textSoundToggle">ğŸ”Š éŸ³æ•ˆï¼šé–‹å•Ÿ</span></button>
                <button class="back-button" id="btnLeaveGame"><span id="textBtnLeaveGame">é›¢é–‹éŠæˆ²</span></button>
            </div>
        </div>

        <!-- â“ éŠæˆ²èªªæ˜é é¢ -->
        <div id="howToPlayScreen" class="menu-screen" style="max-width: 800px;">
            <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">
                <span id="textHowToPlayTitle">ğŸ“– éŠæˆ²èªªæ˜</span>
            </h2>

            <div style="text-align: left; padding: 20px; background: rgba(255,255,255,0.9); border-radius: 15px; margin-bottom: 20px;">
                <!-- åŸºæœ¬è¦å‰‡ -->
                <h3 style="color: #764ba2; margin-top: 0;">
                    <span id="textBasicRulesTitle">ğŸ¯ åŸºæœ¬è¦å‰‡</span>
                </h3>
                <ul style="line-height: 1.8; color: #333;">
                    <li id="textRule1">ğŸ• éŠæˆ²æ™‚é•·ï¼š5 åˆ†é˜</li>
                    <li id="textRule2">ğŸ® æ“ä½œï¼šæ–¹å‘éµ â†‘â†“â†â†’ æˆ– WASD</li>
                    <li id="textRule3">ğŸŸ¡ å°è±†å­ï¼š+10 åˆ†</li>
                    <li id="textRule4">ğŸ”µ èƒ½é‡è±†ï¼š+50 åˆ† + 15 ç§’å¼·åŒ–æ¨¡å¼</li>
                    <li id="textRule5">ğŸ† ç›®æ¨™ï¼šéŠæˆ²çµæŸæ™‚åˆ†æ•¸æœ€é«˜è€…ç²å‹</li>
                </ul>

                <!-- æ¶åˆ†æ©Ÿåˆ¶ -->
                <h3 style="color: #764ba2; margin-top: 20px;">
                    <span id="textScoreStealTitle">âš”ï¸ æ¶åˆ†æ©Ÿåˆ¶</span>
                </h3>
                <div style="background: #f9f9f9; padding: 15px; border-radius: 10px; margin-bottom: 10px;">
                    <p style="margin: 5px 0; color: #333;">
                        <strong style="color: #667eea;">
                            <span id="textNormalVsNormal">æ™®é€š vs æ™®é€š</span>
                        </strong>:
                        <span id="textNormalVsNormalDesc">åˆ†æ•¸é«˜è€…æ¶èµ°å°æ–¹ 20% åˆ†æ•¸</span>
                    </p>
                    <p style="margin: 5px 0; color: #333;">
                        <strong style="color: #ff6b6b;">
                            <span id="textPowerVsNormal">èƒ½é‡è±† vs æ™®é€š</span>
                        </strong>:
                        <span id="textPowerVsNormalDesc">æ¶èµ°å°æ–¹ 50% åˆ†æ•¸ ğŸ’¥</span>
                    </p>
                    <p style="margin: 5px 0; color: #333;">
                        <strong style="color: #ffa500;">
                            <span id="textPowerVsPower">èƒ½é‡è±† vs èƒ½é‡è±†</span>
                        </strong>:
                        <span id="textPowerVsPowerDesc">å½ˆé–‹ï¼Œä¸æ¶åˆ†</span>
                    </p>
                </div>

                <!-- èƒ½é‡è±†æ•ˆæœ -->
                <h3 style="color: #764ba2; margin-top: 20px;">
                    <span id="textPowerPelletTitle">âš¡ èƒ½é‡è±†æ•ˆæœ</span>
                </h3>
                <ul style="line-height: 1.8; color: #333;">
                    <li id="textPower1">ğŸ”µ åƒåˆ°èƒ½é‡è±†å¾Œï¼Œé€²å…¥ 15 ç§’å¼·åŒ–æ¨¡å¼</li>
                    <li id="textPower2">ğŸ’¥ ç¢°åˆ°æ™®é€šç©å®¶æ™‚ï¼Œæ¶èµ° 50% åˆ†æ•¸ï¼ˆè¶…å¼·ï¼ï¼‰</li>
                    <li id="textPower3">âš ï¸ æœ€å¾Œ 5 ç§’æœƒæœ‰è­¦å‘ŠéŸ³æ•ˆ</li>
                    <li id="textPower4">ğŸ—ºï¸ åœ°åœ–ä¸Šå›ºå®šæœ‰ 4 å€‹èƒ½é‡è±†ï¼ˆå››å€‹è§’è½ï¼‰</li>
                </ul>

                <!-- ç­–ç•¥æç¤º -->
                <h3 style="color: #764ba2; margin-top: 20px;">
                    <span id="textStrategyTitle">ğŸ’¡ ç­–ç•¥æç¤º</span>
                </h3>
                <ul style="line-height: 1.8; color: #333;">
                    <li id="textTip1">ğŸ¯ å„ªå…ˆæ¶å¥ªèƒ½é‡è±†ï¼Œå¯ä»¥å¿«é€Ÿé€†è½‰åˆ†æ•¸</li>
                    <li id="textTip2">ğŸ›¡ï¸ åˆ†æ•¸é ˜å…ˆæ™‚ï¼Œé¿é–‹æœ‰èƒ½é‡è±†çš„ç©å®¶</li>
                    <li id="textTip3">âš”ï¸ æœ‰èƒ½é‡è±†æ™‚ï¼Œä¸»å‹•è¿½æ“Šé«˜åˆ†ç©å®¶</li>
                    <li id="textTip4">ğŸƒ è¢«è¿½æ“Šæ™‚ï¼Œå¾€åœ°åœ–é‚Šç·£è·‘æ›´å®‰å…¨</li>
                </ul>

                <!-- AI é›£åº¦èªªæ˜ -->
                <h3 style="color: #764ba2; margin-top: 20px;">
                    <span id="textAIDifficultyTitle">ğŸ¤– AI é›£åº¦èªªæ˜</span>
                </h3>
                <ul style="line-height: 1.8; color: #333;">
                    <li id="textAIEasy">ğŸŸ¢ ç°¡å–®ï¼šé©åˆæ–°æ‰‹ï¼Œåæ‡‰è¼ƒæ…¢ï¼Œå¸¸éš¨æ©Ÿç§»å‹•</li>
                    <li id="textAIMedium">ğŸŸ¡ ä¸­ç­‰ï¼šå¹³è¡¡é›£åº¦ï¼Œæœƒè¿½æ“Šå’Œé€ƒè·‘</li>
                    <li id="textAIHard">ğŸ”´ å›°é›£ï¼šé«˜æ‰‹æŒ‘æˆ°ï¼Œåæ‡‰æ¥µå¿«ï¼Œå„ªå…ˆæ”»æ“Šé«˜åˆ†ç©å®¶</li>
                </ul>
            </div>

            <button class="back-button" id="btnBackFromHowToPlay">
                <span id="textBtnBackFromHowToPlay">è¿”å›ä¸»é¸å–®</span>
            </button>
        </div>
    </div>

    <!-- ğŸ® è™›æ“¬æ–æ¡¿ï¼ˆç§»å‹•ç«¯ï¼‰ -->
    <div class="virtual-joystick" id="virtualJoystick">
        <div class="joystick-base"></div>
        <div class="joystick-stick" id="joystickStick"></div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <!-- AI Player System -->
    <script src="ai-player.js"></script>

    <script>
        // Firebase é…ç½® - è«‹æ›¿æ›ç‚ºä½ è‡ªå·±çš„é…ç½®
        const firebaseConfig = {
            apiKey: "AIzaSyBexampleKey123456789",
            authDomain: "your-project.firebaseapp.com",
            databaseURL: "https://your-project-default-rtdb.firebaseio.com",
            projectId: "your-project",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdef123456"
        };

        // åˆå§‹åŒ– Firebase
        let database;
        let isDemo = false;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.log('Firebase é…ç½®éŒ¯èª¤ - ä½¿ç”¨æ¼”ç¤ºæ¨¡å¼', error);
            isDemo = true;
            // ä¸é¡¯ç¤º alertï¼Œè®“æ¸¬è©¦ç¹¼çºŒ
        }

        // ===========================================
        // ğŸŒ é›™èªç³»çµ± (Traditional Chinese / English)
        // ===========================================
        const translations = {
            'zh-TW': {
                // Page title
                pageTitle: 'ç·šä¸Šå¤šäººå°ç²¾éˆéŠæˆ² (10äººç‰ˆ)',
                mainTitle: 'ğŸ® ç·šä¸Šå¤šäººå°ç²¾éˆ (æœ€å¤š10äºº) ğŸ®',

                // Menu buttons
                btnCreate: 'ğŸ¯ å»ºç«‹éŠæˆ²æˆ¿é–“',
                btnJoin: 'ğŸšª åŠ å…¥éŠæˆ²æˆ¿é–“',
                btnCreateRoom: 'å»ºç«‹æˆ¿é–“',
                btnJoinRoom: 'åŠ å…¥æˆ¿é–“',
                btnBack: 'è¿”å›',
                btnStart: 'é–‹å§‹éŠæˆ²',
                btnLeaveLobby: 'é›¢é–‹æˆ¿é–“',
                btnLeaveGame: 'é›¢é–‹éŠæˆ²',

                // Labels
                labelNickname: 'ä½ çš„æš±ç¨±ï¼š',
                labelRoomCode: 'æˆ¿é–“ä»£ç¢¼ï¼š',
                placeholderNickname: 'è¼¸å…¥ä½ çš„æš±ç¨±',
                placeholderRoomCode: 'è¼¸å…¥6ä½æ•¸æˆ¿é–“ä»£ç¢¼',

                // Lobby
                roomCodeTitle: 'æˆ¿é–“ä»£ç¢¼',
                shareCode: 'åˆ†äº«æ­¤ä»£ç¢¼çµ¦æœ‹å‹åŠ å…¥éŠæˆ²',
                playersJoined: 'å·²åŠ å…¥ç©å®¶',
                waitingMessage: 'ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥... (è‡³å°‘éœ€è¦2ä½ç©å®¶)',

                // Game controls
                controls: 'ä½¿ç”¨æ–¹å‘éµ â†‘ â†“ â† â†’ æˆ– W A S D ç§»å‹•',
                soundOn: 'ğŸ”Š éŸ³æ•ˆï¼šé–‹å•Ÿ',
                soundOff: 'ğŸ”‡ éŸ³æ•ˆï¼šé—œé–‰',

                // Player info
                you: '(ä½ )',
                score: 'åˆ†æ•¸',
                points: 'åˆ†',

                // Alerts
                alertEnterNickname: 'è«‹è¼¸å…¥ä½ çš„æš±ç¨±',
                alertFirebaseNotConfigured: 'Firebase æœªæ­£ç¢ºé…ç½®ï¼Œç„¡æ³•å»ºç«‹æˆ¿é–“',
                alertDemoModeCreate: 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nFirebase æœªé…ç½®ï¼Œç„¡æ³•çœŸæ­£å»ºç«‹ç·šä¸Šæˆ¿é–“ã€‚\né€™åªæ˜¯ç•Œé¢æ¼”ç¤ºã€‚\n\nè¦å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šï¼Œè«‹ä¾ç…§ README é…ç½® Firebaseã€‚',
                alertDemoMode: 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nFirebase æœªé…ç½®ï¼Œç„¡æ³•å•Ÿå‹•éŠæˆ²ã€‚\né€™åªæ˜¯ç•Œé¢æ¼”ç¤ºã€‚\n\nè¦å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šï¼Œè«‹ä¾ç…§ README é…ç½® Firebaseã€‚',
                alertDemoModeJoin: 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nFirebase æœªé…ç½®ï¼Œç„¡æ³•åŠ å…¥ç·šä¸Šæˆ¿é–“ã€‚\n\nè¦å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šï¼Œè«‹ä¾ç…§ README é…ç½® Firebaseã€‚',
                alertFirebaseNotConfiguredJoin: 'Firebase æœªæ­£ç¢ºé…ç½®ï¼Œç„¡æ³•åŠ å…¥æˆ¿é–“',
                alertRoomNotFound: 'æˆ¿é–“ä¸å­˜åœ¨ï¼Œè«‹æª¢æŸ¥æˆ¿é–“ä»£ç¢¼',
                alertInvalidRoomCode: 'è«‹è¼¸å…¥æ­£ç¢ºçš„6ä½æ•¸æˆ¿é–“ä»£ç¢¼',
                alertRoomFull: 'æˆ¿é–“å·²æ»¿ (æœ€å¤š10ä½ç©å®¶)',
                alertGameStarted: 'éŠæˆ²å·²ç¶“é–‹å§‹ï¼Œç„¡æ³•åŠ å…¥',
                alertRoomClosed: 'æˆ¿é–“å·²é—œé–‰',

                // Canvas text
                timer: 'â±ï¸',
                ranking: 'ğŸ† æ’å',
                warning30sec: 'âš ï¸ æœ€å¾Œ 30 ç§’ï¼âš ï¸',
                gameOver: 'ğŸ† éŠæˆ²çµæŸ ğŸ†',
                autoReturn: '15ç§’å¾Œè‡ªå‹•è¿”å›å¤§å»³ï¼Œæˆ–é»æ“Šä¸‹æ–¹æŒ‰éˆ•',

                // æ–°åŠŸèƒ½æŒ‰éˆ•
                btnSoloPractice: 'âš¡ å–®äººç·´ç¿’',
                btnHowToPlay: 'â“ å¦‚ä½•éŠç©',
                btnBackFromHowToPlay: 'è¿”å›ä¸»é¸å–®',

                // éŠæˆ²èªªæ˜é é¢
                textHowToPlayTitle: 'ğŸ“– éŠæˆ²èªªæ˜',
                textBasicRulesTitle: 'ğŸ¯ åŸºæœ¬è¦å‰‡',
                textRule1: 'ğŸ• éŠæˆ²æ™‚é•·ï¼š5 åˆ†é˜',
                textRule2: 'ğŸ® æ“ä½œï¼šæ–¹å‘éµ â†‘â†“â†â†’ æˆ– WASD',
                textRule3: 'ğŸŸ¡ å°è±†å­ï¼š+10 åˆ†',
                textRule4: 'ğŸ”µ èƒ½é‡è±†ï¼š+50 åˆ† + 15 ç§’å¼·åŒ–æ¨¡å¼',
                textRule5: 'ğŸ† ç›®æ¨™ï¼šéŠæˆ²çµæŸæ™‚åˆ†æ•¸æœ€é«˜è€…ç²å‹',

                textScoreStealTitle: 'âš”ï¸ æ¶åˆ†æ©Ÿåˆ¶',
                textNormalVsNormal: 'æ™®é€š vs æ™®é€š',
                textNormalVsNormalDesc: 'åˆ†æ•¸é«˜è€…æ¶èµ°å°æ–¹ 20% åˆ†æ•¸',
                textPowerVsNormal: 'èƒ½é‡è±† vs æ™®é€š',
                textPowerVsNormalDesc: 'æ¶èµ°å°æ–¹ 50% åˆ†æ•¸ ğŸ’¥',
                textPowerVsPower: 'èƒ½é‡è±† vs èƒ½é‡è±†',
                textPowerVsPowerDesc: 'å½ˆé–‹ï¼Œä¸æ¶åˆ†',

                textPowerPelletTitle: 'âš¡ èƒ½é‡è±†æ•ˆæœ',
                textPower1: 'ğŸ”µ åƒåˆ°èƒ½é‡è±†å¾Œï¼Œé€²å…¥ 15 ç§’å¼·åŒ–æ¨¡å¼',
                textPower2: 'ğŸ’¥ ç¢°åˆ°æ™®é€šç©å®¶æ™‚ï¼Œæ¶èµ° 50% åˆ†æ•¸ï¼ˆè¶…å¼·ï¼ï¼‰',
                textPower3: 'âš ï¸ æœ€å¾Œ 5 ç§’æœƒæœ‰è­¦å‘ŠéŸ³æ•ˆ',
                textPower4: 'ğŸ—ºï¸ åœ°åœ–ä¸Šå›ºå®šæœ‰ 4 å€‹èƒ½é‡è±†ï¼ˆå››å€‹è§’è½ï¼‰',

                textStrategyTitle: 'ğŸ’¡ ç­–ç•¥æç¤º',
                textTip1: 'ğŸ¯ å„ªå…ˆæ¶å¥ªèƒ½é‡è±†ï¼Œå¯ä»¥å¿«é€Ÿé€†è½‰åˆ†æ•¸',
                textTip2: 'ğŸ›¡ï¸ åˆ†æ•¸é ˜å…ˆæ™‚ï¼Œé¿é–‹æœ‰èƒ½é‡è±†çš„ç©å®¶',
                textTip3: 'âš”ï¸ æœ‰èƒ½é‡è±†æ™‚ï¼Œä¸»å‹•è¿½æ“Šé«˜åˆ†ç©å®¶',
                textTip4: 'ğŸƒ è¢«è¿½æ“Šæ™‚ï¼Œå¾€åœ°åœ–é‚Šç·£è·‘æ›´å®‰å…¨',

                textAIDifficultyTitle: 'ğŸ¤– AI é›£åº¦èªªæ˜',
                textAIEasy: 'ğŸŸ¢ ç°¡å–®ï¼šé©åˆæ–°æ‰‹ï¼Œåæ‡‰è¼ƒæ…¢ï¼Œå¸¸éš¨æ©Ÿç§»å‹•',
                textAIMedium: 'ğŸŸ¡ ä¸­ç­‰ï¼šå¹³è¡¡é›£åº¦ï¼Œæœƒè¿½æ“Šå’Œé€ƒè·‘',
                textAIHard: 'ğŸ”´ å›°é›£ï¼šé«˜æ‰‹æŒ‘æˆ°ï¼Œåæ‡‰æ¥µå¿«ï¼Œå„ªå…ˆæ”»æ“Šé«˜åˆ†ç©å®¶',

                // Language toggle
                languageToggle: 'English'
            },
            'en': {
                // Page title
                pageTitle: 'Online Multiplayer Pacman (10 Players)',
                mainTitle: 'ğŸ® Online Multiplayer Pacman (Up to 10 Players) ğŸ®',

                // Menu buttons
                btnCreate: 'ğŸ¯ Create Game Room',
                btnJoin: 'ğŸšª Join Game Room',
                btnCreateRoom: 'Create Room',
                btnJoinRoom: 'Join Room',
                btnBack: 'Back',
                btnStart: 'Start Game',
                btnLeaveLobby: 'Leave Room',
                btnLeaveGame: 'Leave Game',

                // Labels
                labelNickname: 'Your Nickname:',
                labelRoomCode: 'Room Code:',
                placeholderNickname: 'Enter your nickname',
                placeholderRoomCode: 'Enter 6-digit room code',

                // Lobby
                roomCodeTitle: 'Room Code',
                shareCode: 'Share this code with friends to join the game',
                playersJoined: 'Players Joined',
                waitingMessage: 'Waiting for other players... (At least 2 players needed)',

                // Game controls
                controls: 'Use Arrow Keys â†‘ â†“ â† â†’ or W A S D to move',
                soundOn: 'ğŸ”Š Sound: ON',
                soundOff: 'ğŸ”‡ Sound: OFF',

                // Player info
                you: '(You)',
                score: 'Score',
                points: 'pts',

                // Alerts
                alertEnterNickname: 'Please enter your nickname',
                alertFirebaseNotConfigured: 'Firebase is not properly configured, cannot create room',
                alertDemoModeCreate: 'âš ï¸ Demo Mode\n\nFirebase is not configured, cannot create online room.\nThis is just a UI demo.\n\nTo enable real multiplayer, please configure Firebase according to the README.',
                alertDemoMode: 'âš ï¸ Demo Mode\n\nFirebase is not configured, cannot start game.\nThis is just a UI demo.\n\nTo enable real multiplayer, please configure Firebase according to the README.',
                alertDemoModeJoin: 'âš ï¸ Demo Mode\n\nFirebase is not configured, cannot join online room.\n\nTo enable real multiplayer, please configure Firebase according to the README.',
                alertFirebaseNotConfiguredJoin: 'Firebase is not properly configured, cannot join room',
                alertRoomNotFound: 'Room does not exist, please check the room code',
                alertInvalidRoomCode: 'Please enter a valid 6-digit room code',
                alertRoomFull: 'Room is full (Maximum 10 players)',
                alertGameStarted: 'Game has already started, cannot join',
                alertRoomClosed: 'Room has been closed',

                // Canvas text
                timer: 'â±ï¸',
                ranking: 'ğŸ† Ranking',
                warning30sec: 'âš ï¸ Last 30 Seconds! âš ï¸',
                gameOver: 'ğŸ† Game Over ğŸ†',
                autoReturn: 'Returning to lobby in 15 seconds, or click the button below',

                // New feature buttons
                btnSoloPractice: 'âš¡ Solo Practice',
                btnHowToPlay: 'â“ How to Play',
                btnBackFromHowToPlay: 'Back to Menu',

                // How to Play page
                textHowToPlayTitle: 'ğŸ“– How to Play',
                textBasicRulesTitle: 'ğŸ¯ Basic Rules',
                textRule1: 'ğŸ• Game Duration: 5 minutes',
                textRule2: 'ğŸ® Controls: Arrow Keys â†‘â†“â†â†’ or WASD',
                textRule3: 'ğŸŸ¡ Small Dot: +10 points',
                textRule4: 'ğŸ”µ Power Pellet: +50 points + 15s Power Mode',
                textRule5: 'ğŸ† Goal: Highest score wins when time runs out',

                textScoreStealTitle: 'âš”ï¸ Score Stealing',
                textNormalVsNormal: 'Normal vs Normal',
                textNormalVsNormalDesc: 'Higher score steals 20% from opponent',
                textPowerVsNormal: 'Power vs Normal',
                textPowerVsNormalDesc: 'Steal 50% from opponent ğŸ’¥',
                textPowerVsPower: 'Power vs Power',
                textPowerVsPowerDesc: 'Bounce off, no stealing',

                textPowerPelletTitle: 'âš¡ Power Pellet Effects',
                textPower1: 'ğŸ”µ Enter 15-second Power Mode after eating',
                textPower2: 'ğŸ’¥ Steal 50% score from normal players (Super strong!)',
                textPower3: 'âš ï¸ Warning sound plays in last 5 seconds',
                textPower4: 'ğŸ—ºï¸ 4 power pellets fixed at map corners',

                textStrategyTitle: 'ğŸ’¡ Strategy Tips',
                textTip1: 'ğŸ¯ Prioritize power pellets for quick comebacks',
                textTip2: 'ğŸ›¡ï¸ Avoid powered players when leading',
                textTip3: 'âš”ï¸ Chase high-score players when powered',
                textTip4: 'ğŸƒ Run to map edges when being chased',

                textAIDifficultyTitle: 'ğŸ¤– AI Difficulty',
                textAIEasy: 'ğŸŸ¢ Easy: Beginner-friendly, slow reaction, random movements',
                textAIMedium: 'ğŸŸ¡ Medium: Balanced difficulty, chases and escapes',
                textAIHard: 'ğŸ”´ Hard: Expert challenge, fast reaction, targets high scores',

                // Language toggle
                languageToggle: 'ä¸­æ–‡'
            }
        };

        // Get current language from localStorage or default to 'zh-TW'
        let currentLanguage = localStorage.getItem('gameLanguage') || 'zh-TW';

        // Get translated text
        function t(key) {
            return translations[currentLanguage][key] || translations['zh-TW'][key] || key;
        }

        // Update all UI text elements
        function updateUILanguage() {
            // Update page title
            document.title = t('pageTitle');

            // Update main elements
            const elementsToUpdate = {
                'mainTitle': 'mainTitle',
                'textBtnCreate': 'btnCreate',
                'textBtnJoin': 'btnJoin',
                'labelHostName': 'labelNickname',
                'labelPlayerName': 'labelNickname',
                'labelRoomCode': 'labelRoomCode',
                'textBtnCreateRoom': 'btnCreateRoom',
                'textBtnJoinRoom': 'btnJoinRoom',
                'textBtnBack1': 'btnBack',
                'textBtnBack2': 'btnBack',
                'textRoomCodeTitle': 'roomCodeTitle',
                'textShareCode': 'shareCode',
                'textPlayersJoined': 'playersJoined',
                'textWaitingMessage': 'waitingMessage',
                'textBtnStart': 'btnStart',
                'textBtnLeaveLobby': 'btnLeaveLobby',
                'textControls': 'controls',
                'textBtnLeaveGame': 'btnLeaveGame'
            };

            for (const [elementId, translationKey] of Object.entries(elementsToUpdate)) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = t(translationKey);
                }
            }

            // Update placeholders
            const placeholderElements = document.querySelectorAll('[data-placeholder-key]');
            placeholderElements.forEach(element => {
                const key = element.getAttribute('data-placeholder-key');
                element.placeholder = t(key);
            });

            // Update sound toggle button
            updateSoundButtonText();

            // Update language toggle button
            document.getElementById('langText').textContent = t('languageToggle');
        }

        // Update sound button text based on current state
        function updateSoundButtonText() {
            const soundBtn = document.getElementById('textSoundToggle');
            if (soundBtn) {
                soundBtn.textContent = isSoundEnabled ? t('soundOn') : t('soundOff');
            }
        }

        // Toggle language
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'zh-TW' ? 'en' : 'zh-TW';
            localStorage.setItem('gameLanguage', currentLanguage);
            updateUILanguage();
        }

        // 10ç¨®ä¸åŒé¡è‰²
        const playerColors = [
            '#FFD700',  // é‡‘é»ƒè‰²
            '#FF69B4',  // ç²‰ç´…è‰²
            '#00CED1',  // é’è—è‰²
            '#32CD32',  // ç¶ è‰²
            '#FF6347',  // ç•ªèŒ„ç´…
            '#9370DB',  // ç´«è‰²
            '#FFA500',  // æ©™è‰²
            '#00FA9A',  // ä¸­ç¶ è‰²
            '#FF1493',  // æ·±ç²‰è‰²
            '#4169E1'   // çš‡å®¶è—
        ];

        // ===========================================
        // ğŸ”Š éŸ³æ•ˆç³»çµ±ï¼ˆWeb Audio APIï¼‰
        // ===========================================
        let audioContext = null;
        let isSoundEnabled = true;

        // åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // è§£é–éŸ³æ•ˆï¼ˆæŸäº›ç€è¦½å™¨éœ€è¦ç”¨æˆ¶äº’å‹•ï¼‰
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // æ’­æ”¾éŸ³æ•ˆçš„é€šç”¨å‡½æ•¸
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            if (!isSoundEnabled) return;

            try {
                initAudio();

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.value = frequency;

                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.log('Audio error:', error);
            }
        }

        // 1. åƒå°è±†å­éŸ³æ•ˆ (wakawaka)
        function soundEatDot() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'square';
                osc.frequency.value = 800;

                gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.05);
            } catch (e) { console.log('Audio error:', e); }
        }

        // 2. åƒèƒ½é‡è±†éŸ³æ•ˆ (power-up ä¸Šå‡éŸ³éš)
        function soundEatPowerPellet() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
            const notes = [523, 659, 784, 1047]; // C-E-G-C å’Œå¼¦

                notes.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'triangle';
                    osc.frequency.value = freq;

                    const startTime = audioContext.currentTime + i * 0.08;
                    gain.gain.setValueAtTime(0.25, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);

                    osc.start(startTime);
                    osc.stop(startTime + 0.2);
                });
            } catch (e) { console.log('Audio error:', e); }
        }

        // 3. é€²å…¥èƒ½é‡æ¨¡å¼éŸ³æ•ˆ (è®Šèº«)
        function soundPowerMode() {
            if (!isSoundEnabled) return;
            try {
                initAudio();

                // å¿«é€Ÿä¸Šå‡éŸ³éš
                for (let i = 0; i < 10; i++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'sawtooth';
                    osc.frequency.value = 200 + i * 80;

                    const startTime = audioContext.currentTime + i * 0.03;
                    gain.gain.setValueAtTime(0.2, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);

                    osc.start(startTime);
                    osc.stop(startTime + 0.1);
                }
            } catch (e) { console.log('Audio error:', e); }
        }

        // 4. ç¢°æ’éŸ³æ•ˆ (ç °)
        function soundCollision() {
            // ğŸ“³ éœ‡å‹•å›é¥‹
            if (window.gameVibrate) window.gameVibrate.collision();

            if (!isSoundEnabled) return;
            try {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);

                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            } catch (e) { console.log('Audio error:', e); }
        }

        // 5. å¾—åˆ†éŸ³æ•ˆ (å®)
        function soundScore() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'sine';
                osc.frequency.value = 1200;

                gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.15);
            } catch (e) { console.log('Audio error:', e); }
        }

        // 6. èƒ½é‡è±†å³å°‡çµæŸè­¦å‘ŠéŸ³ (å˜Ÿå˜Ÿå˜Ÿ)
        function soundPowerWarning() {
            if (!isSoundEnabled) return;
            try {
                initAudio();

                for (let i = 0; i < 3; i++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'square';
                    osc.frequency.value = 600;

                    const startTime = audioContext.currentTime + i * 0.15;
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.08);

                    osc.start(startTime);
                    osc.stop(startTime + 0.08);
                }
            } catch (e) { console.log('Audio error:', e); }
        }

        // 7. éŠæˆ²å€’æ•¸éŸ³æ•ˆ (æ»´ç­”)
        function soundTick() {
            playSound(800, 0.05, 'square', 0.15);
        }

        // 8. éŠæˆ²çµæŸéŸ³æ•ˆ (å‹åˆ©éŸ³æ¨‚)
        function soundGameEnd() {
            if (!isSoundEnabled) return;
            try {
                initAudio();
                const melody = [523, 659, 784, 1047, 784, 1047, 1319]; // C-E-G-C-G-C-E

                melody.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    const startTime = audioContext.currentTime + i * 0.15;
                    gain.gain.setValueAtTime(0.25, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            } catch (e) { console.log('Audio error:', e); }
        }

        // ===========================================
        // ğŸ”§ å·¥å…·å‡½æ•¸ï¼šç¯€æµï¼ˆThrottleï¼‰
        // ===========================================
        /**
         * ç¯€æµå‡½æ•¸ï¼šé™åˆ¶å‡½æ•¸åŸ·è¡Œé »ç‡
         * @param {Function} func - è¦åŸ·è¡Œçš„å‡½æ•¸
         * @param {number} delay - å»¶é²æ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
         * @returns {Function} ç¯€æµå¾Œçš„å‡½æ•¸
         */
        function throttle(func, delay) {
            let lastCall = 0;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return func.apply(this, args);
                }
            };
        }

        // ===========================================
        // éŠæˆ²ç‹€æ…‹èˆ‡å¸¸æ•¸
        // ===========================================

        // ğŸ® éŠæˆ²ç‹€æ…‹è®Šæ•¸
        let currentRoomId = null;
        let currentPlayerId = null;
        let isHost = false;
        let gameState = null;

        // ğŸ¤– AI ç®¡ç†å™¨
        let aiManager = null;
        let aiEnabled = false;
        let aiCount = 0;
        let aiDifficulty = 'medium';

        // ğŸ¨ Canvas è¨­å®š
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CELL_SIZE = 20;
        const COLS = canvas.width / CELL_SIZE;  // 50
        const ROWS = canvas.height / CELL_SIZE;  // 40

        // ğŸ—ï¸ è¿·å®®ç”Ÿæˆå¸¸æ•¸
        const MAZE_CONFIG = {
            WALL_SPAWN_RATE: 0.12,      // ç‰†å£ç”Ÿæˆæ¦‚ç‡ (12%)
            DOT_SPAWN_RATE: 0.65,        // å°è±†å­ç”Ÿæˆæ¦‚ç‡ (65%)
            WALL_GRID_SIZE: 3,           // ç‰†å£ç¶²æ ¼å¤§å°
            PLAYER_SPAWN_CLEAR: 5,       // ç©å®¶èµ·å§‹é»æ¸…ç©ºç¯„åœ (5x5)
            POWER_PELLET_CLEAR: 3        // èƒ½é‡è±†æ¸…ç©ºç¯„åœ (3x3)
        };

        // ğŸ’¯ æ¶åˆ†æ¯”ä¾‹å¸¸æ•¸
        const SCORE_STEAL_RATES = {
            NORMAL_VS_NORMAL: 0.20,      // æ™®é€š vs æ™®é€šï¼š20%
            POWER_VS_NORMAL: 0.50,       // èƒ½é‡è±† vs æ™®é€šï¼š50%
            POWER_VS_POWER: 0.30         // èƒ½é‡è±† vs èƒ½é‡è±†ï¼š30%
        };

        // â±ï¸ æ™‚é–“å¸¸æ•¸ï¼ˆæ¯«ç§’ï¼‰
        const TIME_CONSTANTS = {
            GAME_DURATION: 5 * 60 * 1000,    // éŠæˆ²æ™‚é•·ï¼š5åˆ†é˜
            POWER_MODE_DURATION: 15000,      // èƒ½é‡è±†æ•ˆæœï¼š15ç§’
            POWER_WARNING_TIME: 5000,        // èƒ½é‡è±†è­¦å‘Šï¼šå‰©5ç§’
            COLLISION_COOLDOWN: 1000,        // ç¢°æ’å†·å»ï¼š1ç§’
            MOVE_DELAY: 120,                 // ç§»å‹•å»¶é²ï¼š120æ¯«ç§’
            ROOM_CLEANUP_DELAY: 20000        // æˆ¿é–“æ¸…ç†å»¶é²ï¼š20ç§’
        };

        // ğŸ¯ åˆ†æ•¸å¸¸æ•¸
        const SCORE_VALUES = {
            DOT: 10,                         // å°è±†å­åˆ†æ•¸
            POWER_PELLET: 50                 // èƒ½é‡è±†åˆ†æ•¸
        };

        // ğŸ¨ åœ°åœ–å…ƒç´ å¸¸æ•¸
        const TILE_TYPES = {
            EMPTY: 0,                        // ç©ºåœ°
            WALL: 1,                         // ç‰†å£
            DOT: 2,                          // å°è±†å­
            POWER_PELLET: 3                  // èƒ½é‡è±†
        };
        
        // 10å€‹ä¸åŒçš„èµ·å§‹ä½ç½®
        const startPositions = [
            { x: 2, y: 2 },
            { x: COLS - 3, y: 2 },
            { x: 2, y: ROWS - 3 },
            { x: COLS - 3, y: ROWS - 3 },
            { x: Math.floor(COLS / 2), y: 2 },
            { x: Math.floor(COLS / 2), y: ROWS - 3 },
            { x: 2, y: Math.floor(ROWS / 2) },
            { x: COLS - 3, y: Math.floor(ROWS / 2) },
            { x: Math.floor(COLS / 4), y: Math.floor(ROWS / 4) },
            { x: Math.floor(COLS * 3 / 4), y: Math.floor(ROWS * 3 / 4) }
        ];
        
        // ç”Ÿæˆæˆ¿é–“ä»£ç¢¼
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        // é¡¯ç¤ºå»ºç«‹æˆ¿é–“ç•Œé¢
        function showCreateRoom() {
            console.log('showCreateRoom called');
            document.querySelectorAll('.menu-buttons > button').forEach(b => b.style.display = 'none');
            document.getElementById('createRoomSection').style.display = 'block';
        }
        
        // é¡¯ç¤ºåŠ å…¥æˆ¿é–“ç•Œé¢
        function showJoinRoom() {
            console.log('showJoinRoom called');
            document.querySelectorAll('.menu-buttons > button').forEach(b => b.style.display = 'none');
            document.getElementById('joinRoomSection').style.display = 'block';
        }
        
        // è¿”å›ä¸»é¸å–®
        function backToMenu() {
            document.getElementById('createRoomSection').style.display = 'none';
            document.getElementById('joinRoomSection').style.display = 'none';
            document.querySelectorAll('.menu-buttons > button').forEach(b => b.style.display = 'block');
        }

        // â“ é¡¯ç¤ºéŠæˆ²èªªæ˜é é¢
        function showHowToPlay() {
            document.getElementById('menuScreen').classList.remove('active');
            document.getElementById('howToPlayScreen').classList.add('active');
        }

        // å¾éŠæˆ²èªªæ˜é é¢è¿”å›ä¸»é¸å–®
        function backToMenuFromHowToPlay() {
            document.getElementById('howToPlayScreen').classList.remove('active');
            document.getElementById('menuScreen').classList.add('active');
        }

        // âš¡ å–®äººç·´ç¿’æ¨¡å¼
        async function startSoloPractice() {
            // è‡ªå‹•å¡«å…¥ç©å®¶åç¨±
            const playerName = 'ç©å®¶';

            currentRoomId = generateRoomCode();
            currentPlayerId = 'player_' + Date.now();
            isHost = true;

            // è‡ªå‹•å•Ÿç”¨ AI
            aiEnabled = true;
            aiCount = 9; // 9 å€‹ AI
            aiDifficulty = 'medium'; // ä¸­ç­‰é›£åº¦

            if (!database) {
                // Demo mode - ç›´æ¥æ¨¡æ“¬é–‹å§‹
                alert('æ¼”ç¤ºæ¨¡å¼ï¼šå–®äººç·´ç¿’åŠŸèƒ½éœ€è¦ Firebase é…ç½®æ‰èƒ½æ­£å¸¸é‹ä½œã€‚');
                return;
            }

            try {
                const roomRef = database.ref(`rooms/${currentRoomId}`);

                // å‰µå»ºæˆ¿é–“
                await roomRef.set({
                    code: currentRoomId,
                    status: 'waiting',
                    createdAt: Date.now(),
                    host: currentPlayerId,
                    maxPlayers: 10
                });

                // åŠ å…¥ç©å®¶
                const pos = startPositions[0];
                await database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`).set({
                    name: playerName,
                    color: playerColors[0],
                    score: 0,
                    x: pos.x,
                    y: pos.y,
                    joinedAt: Date.now()
                });

                // è¨­å®šæ–·ç·šè™•ç†
                database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`).onDisconnect().remove();

                // ç”Ÿæˆè¿·å®®
                const maze = generateMaze();

                // æ·»åŠ  9 å€‹ AI ç©å®¶
                for (let i = 0; i < 9; i++) {
                    const aiId = `ai_${Date.now()}_${i}`;
                    const aiName = `AI-${i + 1}`;
                    const playerIndex = i + 1;
                    const aiPos = startPositions[playerIndex];

                    await database.ref(`rooms/${currentRoomId}/players/${aiId}`).set({
                        name: aiName,
                        color: playerColors[playerIndex],
                        score: 0,
                        x: aiPos.x,
                        y: aiPos.y,
                        joinedAt: Date.now(),
                        isAI: true,
                        aiDifficulty: aiDifficulty
                    });
                }

                // ç›´æ¥é–‹å§‹éŠæˆ²
                await roomRef.update({
                    status: 'playing',
                    maze: maze,
                    startedAt: Date.now()
                });

                console.log('Solo practice mode started successfully');

                // ç›£è½æˆ¿é–“è®ŠåŒ–
                listenToRoom();

            } catch (error) {
                console.error('Error starting solo practice:', error);
                alert('å•Ÿå‹•å–®äººç·´ç¿’æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
            }
        }

        // å»ºç«‹æˆ¿é–“
        async function createRoom() {
            console.log('createRoom function called');
            const hostName = document.getElementById('hostName').value.trim();
            console.log('Host name:', hostName);

            if (!hostName) {
                alert(t('alertEnterNickname'));
                return;
            }

            console.log('Database status:', database ? 'Available' : 'Not available');

            if (!database) {
                alert(t('alertFirebaseNotConfigured'));
                return;
            }

            console.log('Creating room...');

            const roomCode = generateRoomCode();
            currentRoomId = roomCode;
            currentPlayerId = 'player_' + Date.now();
            isHost = true;

            // æ¼”ç¤ºæ¨¡å¼ - ç›´æ¥åˆ‡æ›åˆ°ç­‰å¾…å®¤
            if (isDemo) {
                console.log('Demo mode - switching to lobby');
                alert(t('alertDemoModeCreate'));
                document.getElementById('menuScreen').classList.remove('active');
                document.getElementById('lobbyScreen').classList.add('active');
                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('playerCount').textContent = '1';
                document.getElementById('playersList').innerHTML = `
                    <div class="player-item" style="background: ${playerColors[0]}20; border: 2px solid ${playerColors[0]}">
                        <div class="player-color-dot" style="background: ${playerColors[0]}"></div>
                        <span style="color: #333">${hostName} ${t('you')}</span>
                    </div>
                `;
                return;
            }
            
            const roomRef = database.ref(`rooms/${roomCode}`);
            const playerRef = database.ref(`rooms/${roomCode}/players/${currentPlayerId}`);
            
            // å»ºç«‹æˆ¿é–“è³‡æ–™
            await roomRef.set({
                code: roomCode,
                status: 'waiting',
                createdAt: Date.now(),
                host: currentPlayerId,
                maxPlayers: 10
            });
            
            // åŠ å…¥ç©å®¶
            const pos = startPositions[0];
            await playerRef.set({
                name: hostName,
                color: playerColors[0],
                score: 0,
                x: pos.x,
                y: pos.y,
                joinedAt: Date.now()
            });
            
            // è¨­å®šæ–·ç·šè™•ç†
            playerRef.onDisconnect().remove();
            
            // ç›£è½æˆ¿é–“è®ŠåŒ–
            listenToRoom();
            
            // åˆ‡æ›åˆ°ç­‰å¾…å®¤
            document.getElementById('menuScreen').classList.remove('active');
            document.getElementById('lobbyScreen').classList.add('active');
            document.getElementById('displayRoomCode').textContent = roomCode;
        }
        
        // åŠ å…¥æˆ¿é–“
        async function joinRoom() {
            console.log('joinRoom function called');
            const playerName = document.getElementById('playerName').value.trim();
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();

            console.log('Player name:', playerName);
            console.log('Room code:', roomCode);

            if (!playerName) {
                alert(t('alertEnterNickname'));
                return;
            }

            if (!roomCode || roomCode.length !== 6) {
                alert(t('alertInvalidRoomCode'));
                return;
            }

            if (isDemo) {
                alert(t('alertDemoModeJoin'));
                return;
            }

            console.log('Database status:', database ? 'Available' : 'Not available');

            if (!database) {
                alert(t('alertFirebaseNotConfiguredJoin'));
                return;
            }

            // æª¢æŸ¥æˆ¿é–“æ˜¯å¦å­˜åœ¨
            const roomRef = database.ref(`rooms/${roomCode}`);
            const snapshot = await roomRef.once('value');

            if (!snapshot.exists()) {
                alert(t('alertRoomNotFound'));
                return;
            }

            const roomData = snapshot.val();
            const playerCount = roomData.players ? Object.keys(roomData.players).length : 0;

            if (playerCount >= 10) {
                alert(t('alertRoomFull'));
                return;
            }

            if (roomData.status === 'playing') {
                alert(t('alertGameStarted'));
                return;
            }
            
            currentRoomId = roomCode;
            currentPlayerId = 'player_' + Date.now();
            
            const playerRef = database.ref(`rooms/${roomCode}/players/${currentPlayerId}`);
            
            // åŠ å…¥ç©å®¶
            const pos = startPositions[playerCount];
            await playerRef.set({
                name: playerName,
                color: playerColors[playerCount],
                score: 0,
                x: pos.x,
                y: pos.y,
                joinedAt: Date.now()
            });
            
            // è¨­å®šæ–·ç·šè™•ç†
            playerRef.onDisconnect().remove();
            
            // ç›£è½æˆ¿é–“è®ŠåŒ–
            listenToRoom();
            
            // åˆ‡æ›åˆ°ç­‰å¾…å®¤
            document.getElementById('menuScreen').classList.remove('active');
            document.getElementById('lobbyScreen').classList.add('active');
            document.getElementById('displayRoomCode').textContent = roomCode;
        }
        
        // ç›£è½æˆ¿é–“è®ŠåŒ–
        function listenToRoom() {
            const roomRef = database.ref(`rooms/${currentRoomId}`);

            roomRef.on('value', (snapshot) => {
                const data = snapshot.val();

                if (!data) {
                    alert(t('alertRoomClosed'));
                    window.location.reload();
                    return;
                }
                
                // æ›´æ–°ç©å®¶åˆ—è¡¨
                updatePlayersList(data.players || {});
                
                // æª¢æŸ¥æ˜¯å¦å¯ä»¥é–‹å§‹éŠæˆ²
                const playerCount = Object.keys(data.players || {}).length;
                const startButton = document.getElementById('startButton');
                if (isHost && playerCount >= 2) {
                    startButton.disabled = false;
                }
                
                // å¦‚æœéŠæˆ²é–‹å§‹ï¼Œåˆ‡æ›åˆ°éŠæˆ²ç•«é¢
                if (data.status === 'playing' && !gameState) {
                    initGame(data);
                } else if (data.status === 'playing' && gameState) {
                    updateGameState(data);
                }
            });
        }
        
        // æ›´æ–°ç©å®¶åˆ—è¡¨
        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            const playerCount = document.getElementById('playerCount');

            playerCount.textContent = Object.keys(players).length;
            playersList.innerHTML = '';

            Object.entries(players).forEach(([id, player]) => {
                const div = document.createElement('div');
                div.className = 'player-item';
                div.style.background = player.color + '20';
                div.style.border = `2px solid ${player.color}`;

                const dot = document.createElement('div');
                dot.className = 'player-color-dot';
                dot.style.background = player.color;

                const name = document.createElement('span');
                name.textContent = `${player.name} ${id === currentPlayerId ? t('you') : ''}`;
                name.style.color = '#333';

                div.appendChild(dot);
                div.appendChild(name);
                playersList.appendChild(div);
            });
        }
        
        // é–‹å§‹éŠæˆ²
        async function startGame() {
            if (!isHost) return;

            // ğŸ”§ æ¼”ç¤ºæ¨¡å¼æª¢æŸ¥
            if (isDemo) {
                alert(t('alertDemoMode') || 'âš ï¸ æ¼”ç¤ºæ¨¡å¼\n\nç„¡æ³•å•Ÿå‹•éŠæˆ²ï¼Œå› ç‚º Firebase æœªé…ç½®ã€‚\nè«‹ä¾ç…§ README è¨­å®š Firebase ä»¥å•Ÿç”¨çœŸæ­£çš„å¤šäººé€£ç·šã€‚');
                return;
            }

            if (!database) {
                alert(t('alertFirebaseNotConfigured'));
                return;
            }

            try {
                const roomRef = database.ref(`rooms/${currentRoomId}`);
                const snapshot = await roomRef.once('value');
                const roomData = snapshot.val();

                if (!roomData) {
                    alert(t('alertRoomNotFound'));
                    return;
                }

                // ç”Ÿæˆè¿·å®®
                const maze = generateMaze();

                // ğŸ¤– æ·»åŠ  AI ç©å®¶ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
                if (aiEnabled && aiCount > 0) {
                    const currentPlayers = roomData.players ? Object.keys(roomData.players).length : 0;
                    const maxAI = Math.min(aiCount, 10 - currentPlayers); // ä¸è¶…éæˆ¿é–“ä¸Šé™

                    for (let i = 0; i < maxAI; i++) {
                        const aiId = `ai_${Date.now()}_${i}`;
                        const aiName = `AI-${aiDifficulty.toUpperCase()}-${i + 1}`;
                        const playerIndex = currentPlayers + i;
                        const pos = startPositions[playerIndex];

                        await database.ref(`rooms/${currentRoomId}/players/${aiId}`).set({
                            name: aiName,
                            color: playerColors[playerIndex],
                            score: 0,
                            x: pos.x,
                            y: pos.y,
                            joinedAt: Date.now(),
                            isAI: true,
                            aiDifficulty: aiDifficulty
                        });

                        console.log(`AI player added: ${aiName}`);
                    }
                }

                // æ›´æ–°æˆ¿é–“ç‹€æ…‹
                await roomRef.update({
                    status: 'playing',
                    maze: maze,
                    startedAt: Date.now()
                });

                console.log('Game started successfully');
            } catch (error) {
                console.error('Error starting game:', error);
                alert('å•Ÿå‹•éŠæˆ²æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
            }
        }
        
        /**
         * ç”ŸæˆéŠæˆ²è¿·å®®
         * @returns {Array<Array<number>>} è¿·å®®äºŒç¶­é™£åˆ—
         *
         * åœ°åœ–å…ƒç´ ï¼š
         * - 0: ç©ºåœ°
         * - 1: ç‰†å£
         * - 2: å°è±†å­ï¼ˆ+10 åˆ†ï¼‰
         * - 3: èƒ½é‡è±†ï¼ˆ+50 åˆ†ï¼‰
         *
         * ç”Ÿæˆé‚è¼¯ï¼š
         * 1. å»ºç«‹é‚Šç•Œç‰†ï¼ˆåœ°åœ–å››å‘¨ï¼‰
         * 2. éš¨æ©Ÿç”Ÿæˆå…§éƒ¨ç‰†å£ï¼ˆ12% æ¦‚ç‡ï¼Œåªåœ¨ 3çš„å€æ•¸åº§æ¨™ï¼‰
         * 3. æ”¾ç½®å°è±†å­ï¼ˆ65% æ¦‚ç‡ï¼‰
         * 4. æ¸…ç©ºç©å®¶èµ·å§‹ä½ç½®å‘¨åœå€åŸŸï¼ˆ5x5ï¼‰
         * 5. å›ºå®šæ”¾ç½® 4 å€‹èƒ½é‡è±†åœ¨åœ°åœ–å››è§’
         * 6. æ¸…ç©ºèƒ½é‡è±†å‘¨åœå€åŸŸï¼ˆ3x3ï¼‰
         */
        function generateMaze() {
            const maze = [];

            // æ­¥é©Ÿ 1-3ï¼šç”ŸæˆåŸºæœ¬åœ°åœ–ï¼ˆç‰†å£ã€å°è±†å­ã€ç©ºåœ°ï¼‰
            for (let y = 0; y < ROWS; y++) {
                maze[y] = [];
                for (let x = 0; x < COLS; x++) {
                    if (x === 0 || x === COLS - 1 || y === 0 || y === ROWS - 1) {
                        maze[y][x] = TILE_TYPES.WALL; // é‚Šç•Œç‰†
                    } else if (Math.random() < MAZE_CONFIG.WALL_SPAWN_RATE &&
                               (x % MAZE_CONFIG.WALL_GRID_SIZE === 0 && y % MAZE_CONFIG.WALL_GRID_SIZE === 0)) {
                        maze[y][x] = TILE_TYPES.WALL; // å…§éƒ¨ç‰†å£ï¼ˆç¶²æ ¼ç‹€åˆ†å¸ƒï¼‰
                    } else if (Math.random() < MAZE_CONFIG.DOT_SPAWN_RATE) {
                        maze[y][x] = TILE_TYPES.DOT; // å°è±†å­
                    } else {
                        maze[y][x] = TILE_TYPES.EMPTY; // ç©ºåœ°
                    }
                }
            }

            // æ­¥é©Ÿ 4ï¼šæ¸…ç©ºç©å®¶èµ·å§‹ä½ç½®å‘¨åœï¼ˆç¢ºä¿ç©å®¶å¯ä»¥ç§»å‹•ï¼‰
            startPositions.forEach(pos => {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const ny = pos.y + dy;
                        const nx = pos.x + dx;
                        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                            if (maze[ny][nx] === 1) maze[ny][nx] = 0; // ç§»é™¤ç‰†å£
                        }
                    }
                }
            });

            // æ­¥é©Ÿ 5-6ï¼šå›ºå®šæ”¾ç½® 4 å€‹èƒ½é‡è±†ï¼ˆåœ°åœ–å››è§’ï¼‰
            const powerPelletPositions = [
                { x: 5, y: 5 },                    // å·¦ä¸Šè§’
                { x: COLS - 6, y: 5 },             // å³ä¸Šè§’
                { x: 5, y: ROWS - 6 },             // å·¦ä¸‹è§’
                { x: COLS - 6, y: ROWS - 6 }       // å³ä¸‹è§’
            ];

            powerPelletPositions.forEach(pos => {
                // æ¸…ç©ºèƒ½é‡è±†å‘¨åœå€åŸŸï¼ˆ3x3ï¼‰ï¼Œç¢ºä¿ç©å®¶å¯ä»¥æ¥è¿‘
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const ny = pos.y + dy;
                        const nx = pos.x + dx;
                        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                            if (maze[ny][nx] === 1) maze[ny][nx] = 0; // ç§»é™¤ç‰†å£
                        }
                    }
                }
                // æ”¾ç½®èƒ½é‡è±†
                maze[pos.y][pos.x] = 3;
            });

            console.log('Maze generated successfully');
            return maze;
        }
        
        // åˆå§‹åŒ–éŠæˆ²
        function initGame(data) {
            gameState = data;

            document.getElementById('lobbyScreen').classList.remove('active');
            document.getElementById('gameScreen').classList.add('active');

            // ğŸ¤– åˆå§‹åŒ– AI ç®¡ç†å™¨
            if (typeof AIManager !== 'undefined') {
                aiManager = new AIManager();
                aiManager.setGameState(gameState);

                // ç‚ºæ¯å€‹ AI ç©å®¶å‰µå»º AI å¯¦ä¾‹
                if (data.players) {
                    Object.entries(data.players).forEach(([id, player]) => {
                        if (player.isAI) {
                            const difficulty = player.aiDifficulty || 'medium';
                            const ai = aiManager.createAI(id, player.name, difficulty);
                            ai.x = player.x;
                            ai.y = player.y;
                            ai.score = player.score;
                            ai.start(); // å•Ÿå‹• AI
                            console.log(`AI ${player.name} initialized with difficulty ${difficulty}`);
                        }
                    });
                }
            }

            // æ›´æ–°ç©å®¶è³‡è¨Šé¢æ¿
            updateInfoPanel(data.players);

            // é–‹å§‹éŠæˆ²å¾ªç’°
            gameLoop();

            // ç›£è½éµç›¤
            setupKeyboardControls();

            // ç›£è½è§¸æ§ï¼ˆç§»å‹•ç«¯ï¼‰
            setupTouchControls();
        }
        
        // æ›´æ–°ç©å®¶è³‡è¨Šé¢æ¿
        function updateInfoPanel(players) {
            const panel = document.getElementById('gameInfoPanel');
            panel.innerHTML = '';

            Object.entries(players).forEach(([id, player]) => {
                const div = document.createElement('div');
                div.className = 'player-info';
                div.style.background = `linear-gradient(135deg, ${player.color} 0%, ${player.color}CC 100%)`;
                div.innerHTML = `
                    <div style="font-size: 0.85em;">${player.name}${id === currentPlayerId ? ' ' + t('you') : ''}</div>
                    <div>${t('score')}: <span id="score-${id}">${player.score || 0}</span></div>
                `;
                panel.appendChild(div);
            });
        }
        
        /**
         * è¨­å®šéµç›¤æ§åˆ¶
         *
         * æ”¹é€²é»ï¼š
         * 1. åŠ å…¥æ›´å¥½çš„éŒ¯èª¤è™•ç†
         * 2. é˜²æ­¢é‡è¤‡ç›£è½
         * 3. åŠ å…¥è©³ç´°æ—¥èªŒ
         */
        let keyboardListenerAdded = false; // é˜²æ­¢é‡è¤‡æ·»åŠ ç›£è½å™¨

        function setupKeyboardControls() {
            if (keyboardListenerAdded) {
                console.log('Keyboard controls already set up');
                return;
            }

            let lastMoveTime = 0;
            const moveDelay = 120; // ç§»å‹•å»¶é²ï¼ˆæ¯«ç§’ï¼‰

            document.addEventListener('keydown', async (e) => {
                if (!gameState || Date.now() - lastMoveTime < moveDelay) return;

                if (!database || !currentRoomId || !currentPlayerId) {
                    console.warn('Cannot move: missing database, room, or player ID');
                    return;
                }

                try {
                    const playerRef = database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`);
                    const snapshot = await playerRef.once('value');
                    const player = snapshot.val();

                    if (!player) {
                        console.warn('Player data not found');
                        return;
                    }
                
                let newX = player.x;
                let newY = player.y;
                
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    newY--;
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    newY++;
                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    newX--;
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    newX++;
                } else {
                    return;
                }
                
                    e.preventDefault();

                    // æª¢æŸ¥é‚Šç•Œå’Œç¢°æ’
                    if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                        if (gameState.maze[newY][newX] !== 1) {
                            lastMoveTime = Date.now();

                            const updates = {
                                x: newX,
                                y: newY
                            };

                            // æª¢æŸ¥æ˜¯å¦åƒåˆ°è±†å­
                            if (gameState.maze[newY][newX] === 2) {
                                updates.score = (player.score || 0) + 10;
                                await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                soundEatDot(); // ğŸ”Š åƒè±†å­éŸ³æ•ˆ
                                window.gameVibrate?.eatDot(); // ğŸ“³ éœ‡å‹•å›é¥‹
                            } else if (gameState.maze[newY][newX] === 3) {
                                // åƒåˆ°èƒ½é‡è±†ï¼šåŠ åˆ† + é€²å…¥ power mode
                                updates.score = (player.score || 0) + 50;
                                updates.powerMode = true;
                                updates.powerEndTime = Date.now() + 15000; // 15ç§’ power mode
                                await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                soundEatPowerPellet(); // ğŸ”Š åƒèƒ½é‡è±†éŸ³æ•ˆ
                                window.gameVibrate?.eatPowerPellet(); // ğŸ“³ éœ‡å‹•å›é¥‹
                                setTimeout(() => soundPowerMode(), 320); // ğŸ”Š è®Šèº«éŸ³æ•ˆï¼ˆå»¶é²æ’­æ”¾ï¼‰
                            }

                            await playerRef.update(updates);

                            // æª¢æŸ¥ç¢°æ’ï¼ˆç§»å‹•å¾Œï¼‰
                            checkCollision(newX, newY);
                        }
                    }
                } catch (error) {
                    console.error('Error handling keyboard input:', error);
                }
            });

            keyboardListenerAdded = true;
            console.log('Keyboard controls set up successfully');
        }

        /**
         * ğŸ® è¨­ç½®è™›æ“¬æ–æ¡¿æ§åˆ¶ï¼ˆç§»å‹•ç«¯ï¼‰
         *
         * åŠŸèƒ½ï¼š
         * - è§¸æ§è™›æ“¬æ–æ¡¿ç§»å‹•ç©å®¶
         * - è¦–è¦ºå›é¥‹ï¼ˆæ–æ¡¿ç§»å‹•ï¼‰
         * - èˆ‡éµç›¤æ§åˆ¶å…±ç”¨ç§»å‹•å»¶é²
         *
         * @returns {void}
         */
        function setupTouchControls() {
            const joystick = document.getElementById('virtualJoystick');
            const stick = document.getElementById('joystickStick');

            if (!joystick || !stick) {
                console.warn('Virtual joystick elements not found');
                return;
            }

            let touchStartTime = 0;
            const touchMoveDelay = 120; // èˆ‡éµç›¤ç§»å‹•å»¶é²ç›¸åŒ
            let lastTouchMoveTime = 0;
            let touchActive = false;
            let moveInterval = null;

            // è§¸æ§é–‹å§‹
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchActive = true;
                touchStartTime = Date.now();
                stick.classList.add('active');
                console.log('Touch started');
            }, { passive: false });

            // è§¸æ§ç§»å‹•
            joystick.addEventListener('touchmove', async (e) => {
                e.preventDefault();
                if (!touchActive || !gameState) return;

                const now = Date.now();
                if (now - lastTouchMoveTime < touchMoveDelay) return;

                try {
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    // è¨ˆç®—è§¸æ§é»ç›¸å°æ–¼ä¸­å¿ƒçš„åç§»
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;

                    // è¨ˆç®—è·é›¢å’Œè§’åº¦
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20; // æ–æ¡¿ç§»å‹•æœ€å¤§è·é›¢

                    // é™åˆ¶æ–æ¡¿ç§»å‹•ç¯„åœ
                    const limitedDistance = Math.min(distance, maxDistance);
                    const angle = Math.atan2(deltaY, deltaX);

                    // æ›´æ–°æ–æ¡¿è¦–è¦ºä½ç½®
                    const stickX = Math.cos(angle) * limitedDistance;
                    const stickY = Math.sin(angle) * limitedDistance;
                    stick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;

                    // åˆ¤æ–·ä¸»è¦ç§»å‹•æ–¹å‘ï¼ˆéœ€è¦è¶³å¤ çš„åç§»é‡æ‰è§¸ç™¼ç§»å‹•ï¼‰
                    const threshold = 15; // è§¸ç™¼ç§»å‹•çš„æœ€å°è·é›¢
                    if (distance < threshold) return;

                    let direction = null;
                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);

                    // é¸æ“‡ä¸»è¦æ–¹å‘ï¼ˆX æˆ– Y è»¸ï¼‰
                    if (absX > absY) {
                        direction = deltaX > 0 ? 'right' : 'left';
                    } else {
                        direction = deltaY > 0 ? 'down' : 'up';
                    }

                    // åŸ·è¡Œç§»å‹•
                    if (direction && database && currentRoomId && currentPlayerId) {
                        const playerRef = database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`);
                        const snapshot = await playerRef.once('value');
                        const player = snapshot.val();

                        if (!player) {
                            console.warn('Player data not found');
                            return;
                        }

                        let newX = player.x;
                        let newY = player.y;

                        switch (direction) {
                            case 'up': newY--; break;
                            case 'down': newY++; break;
                            case 'left': newX--; break;
                            case 'right': newX++; break;
                        }

                        // æª¢æŸ¥é‚Šç•Œå’Œç¢°æ’
                        if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                            if (gameState.maze[newY][newX] !== 1) {
                                lastTouchMoveTime = now;

                                const updates = {
                                    x: newX,
                                    y: newY
                                };

                                // æª¢æŸ¥æ˜¯å¦åƒåˆ°è±†å­
                                if (gameState.maze[newY][newX] === 2) {
                                    updates.score = (player.score || 0) + 10;
                                    await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                    soundEatDot(); // ğŸ”Š åƒè±†å­éŸ³æ•ˆ
                                    window.gameVibrate?.eatDot(); // ğŸ“³ éœ‡å‹•å›é¥‹
                                } else if (gameState.maze[newY][newX] === 3) {
                                    // åƒåˆ°èƒ½é‡è±†ï¼šåŠ åˆ† + é€²å…¥ power mode
                                    updates.score = (player.score || 0) + 50;
                                    updates.powerMode = true;
                                    updates.powerEndTime = Date.now() + 15000; // 15ç§’ power mode
                                    await database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                                    soundEatPowerPellet(); // ğŸ”Š åƒèƒ½é‡è±†éŸ³æ•ˆ
                                    window.gameVibrate?.eatPowerPellet(); // ğŸ“³ éœ‡å‹•å›é¥‹
                                    setTimeout(() => soundPowerMode(), 320); // ğŸ”Š è®Šèº«éŸ³æ•ˆï¼ˆå»¶é²æ’­æ”¾ï¼‰
                                }

                                await playerRef.update(updates);

                                // æª¢æŸ¥ç¢°æ’ï¼ˆç§»å‹•å¾Œï¼‰
                                checkCollision(newX, newY);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error handling touch input:', error);
                }
            }, { passive: false });

            // è§¸æ§çµæŸ
            const handleTouchEnd = (e) => {
                e.preventDefault();
                touchActive = false;
                stick.classList.remove('active');
                // é‡ç½®æ–æ¡¿ä½ç½®ï¼ˆå›åˆ°ä¸­å¿ƒï¼‰
                stick.style.transform = 'translate(-50%, -50%)';

                if (moveInterval) {
                    clearInterval(moveInterval);
                    moveInterval = null;
                }
                console.log('Touch ended');
            };

            joystick.addEventListener('touchend', handleTouchEnd, { passive: false });
            joystick.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            console.log('Touch controls set up successfully');
        }

        // ğŸ”§ ç¢°æ’å†·å»è¿½è¹¤ï¼ˆé¿å…é‡è¤‡ç¢°æ’ï¼‰
        let lastCollisionTime = {};
        const COLLISION_COOLDOWN = 1000; // 1ç§’ç¢°æ’å†·å»

        /**
         * æª¢æŸ¥ç©å®¶ç¢°æ’ä¸¦åŸ·è¡Œæ¶åˆ†
         * @param {number} myX - è‡ªå·±çš„ X åº§æ¨™
         * @param {number} myY - è‡ªå·±çš„ Y åº§æ¨™
         *
         * æ”¹é€²é»ï¼š
         * 1. åŠ å…¥ç¢°æ’å†·å»ï¼ˆé¿å…çŸ­æ™‚é–“å…§é‡è¤‡ç¢°æ’ï¼‰
         * 2. åªè®“ ID è¼ƒå°çš„ç©å®¶è™•ç†ç¢°æ’ï¼ˆé¿å…é›™æ–¹åŒæ™‚è™•ç†å°è‡´é›™å€æ‰£åˆ†ï¼‰
         * 3. æ›´å¥½çš„éŒ¯èª¤è™•ç†
         */
        async function checkCollision(myX, myY) {
            if (!gameState || !gameState.players || !currentPlayerId || !database) return;

            const myPlayer = gameState.players[currentPlayerId];
            if (!myPlayer) return;

            const now = Date.now();
            const myPowerMode = myPlayer.powerMode && myPlayer.powerEndTime && now < myPlayer.powerEndTime;

            // éæ­·æ‰€æœ‰å…¶ä»–ç©å®¶
            for (const [otherId, otherPlayer] of Object.entries(gameState.players)) {
                if (otherId === currentPlayerId) continue; // è·³éè‡ªå·±

                // ğŸ”§ æª¢æŸ¥ç¢°æ’å†·å»ï¼ˆé¿å…çŸ­æ™‚é–“å…§é‡è¤‡è™•ç†ï¼‰
                const collisionKey = [currentPlayerId, otherId].sort().join('-');
                if (lastCollisionTime[collisionKey] && now - lastCollisionTime[collisionKey] < COLLISION_COOLDOWN) {
                    continue; // é‚„åœ¨å†·å»ä¸­ï¼Œè·³é
                }

                // æª¢æŸ¥ä½ç½®æ˜¯å¦é‡ç–Šï¼ˆåŒä¸€æ ¼æˆ–ç›¸é„°ï¼‰
                const distance = Math.abs(myX - otherPlayer.x) + Math.abs(myY - otherPlayer.y);
                if (distance <= 1) { // ç¢°æ’ï¼
                    // ğŸ”§ åªè®“ ID è¼ƒå°çš„ç©å®¶è™•ç†ç¢°æ’ï¼ˆé¿å…é›™æ–¹åŒæ™‚è™•ç†ï¼‰
                    if (currentPlayerId > otherId) {
                        console.log('Collision detected but handled by other player');
                        continue;
                    }
                    const otherPowerMode = otherPlayer.powerMode && otherPlayer.powerEndTime && now < otherPlayer.powerEndTime;

                    let myScoreChange = 0;
                    let otherScoreChange = 0;

                    // åˆ¤æ–·æ¶åˆ†è¦å‰‡
                    if (myPowerMode && !otherPowerMode) {
                        // æˆ‘åœ¨ power modeï¼Œå°æ–¹ä¸åœ¨ï¼šæ¶ 50%
                        const stolen = Math.floor((otherPlayer.score || 0) * SCORE_STEAL_RATES.POWER_VS_NORMAL);
                        myScoreChange = stolen;
                        otherScoreChange = -stolen;
                        showScoreFloating(myX, myY, `+${stolen}`, '#00FF00');
                        showScoreFloating(otherPlayer.x, otherPlayer.y, `-${stolen}`, '#FF0000');
                        soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        if (stolen > 0) soundScore(); // ğŸ”Š å¾—åˆ†éŸ³æ•ˆ
                    } else if (!myPowerMode && otherPowerMode) {
                        // å°æ–¹åœ¨ power modeï¼Œæˆ‘ä¸åœ¨ï¼šè¢«æ¶ 50%
                        const stolen = Math.floor((myPlayer.score || 0) * SCORE_STEAL_RATES.POWER_VS_NORMAL);
                        myScoreChange = -stolen;
                        otherScoreChange = stolen;
                        showScoreFloating(myX, myY, `-${stolen}`, '#FF0000');
                        soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                    } else if (myPowerMode && otherPowerMode) {
                        // é›™æ–¹éƒ½åœ¨ power modeï¼šå½ˆé–‹ï¼Œä¸æ¶åˆ†
                        console.log('Both in power mode - bounce!');
                        soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        return;
                    } else {
                        // é›™æ–¹éƒ½ä¸åœ¨ power modeï¼šåˆ†æ•¸é«˜è€…æ¶ 20%
                        const myScore = myPlayer.score || 0;
                        const otherScore = otherPlayer.score || 0;

                        if (myScore > otherScore) {
                            const stolen = Math.floor(otherScore * SCORE_STEAL_RATES.NORMAL_VS_NORMAL);
                            myScoreChange = stolen;
                            otherScoreChange = -stolen;
                            showScoreFloating(myX, myY, `+${stolen}`, '#00FF00');
                            showScoreFloating(otherPlayer.x, otherPlayer.y, `-${stolen}`, '#FF0000');
                            soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                            if (stolen > 0) soundScore(); // ğŸ”Š å¾—åˆ†éŸ³æ•ˆ
                        } else if (otherScore > myScore) {
                            const stolen = Math.floor(myScore * SCORE_STEAL_RATES.NORMAL_VS_NORMAL);
                            myScoreChange = -stolen;
                            otherScoreChange = stolen;
                            showScoreFloating(myX, myY, `-${stolen}`, '#FF0000');
                            soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        } else {
                            // åˆ†æ•¸ç›¸ç­‰ï¼šåªæœ‰ç¢°æ’éŸ³æ•ˆ
                            soundCollision(); // ğŸ”Š ç¢°æ’éŸ³æ•ˆ
                        }
                    }

                    // ğŸ”§ è¨˜éŒ„ç¢°æ’æ™‚é–“ï¼ˆå†·å»ï¼‰
                    lastCollisionTime[collisionKey] = now;

                    // æ›´æ–°åˆ†æ•¸ï¼ˆç¢ºä¿ä¸æœƒè®Šæˆè² æ•¸ï¼‰
                    try {
                        if (myScoreChange !== 0) {
                            const newScore = Math.max(0, (myPlayer.score || 0) + myScoreChange);
                            await database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}/score`).set(newScore);
                        }
                        if (otherScoreChange !== 0) {
                            const newOtherScore = Math.max(0, (otherPlayer.score || 0) + otherScoreChange);
                            await database.ref(`rooms/${currentRoomId}/players/${otherId}/score`).set(newOtherScore);
                        }
                        console.log(`Collision processed: ${currentPlayerId} vs ${otherId}, scores: ${myScoreChange}, ${otherScoreChange}`);
                    } catch (error) {
                        console.error('Error updating scores after collision:', error);
                    }

                    break; // åªè™•ç†ç¬¬ä¸€å€‹ç¢°æ’
                }
            }
        }

        // åˆ†æ•¸é£„å­—å‹•ç•«æ•¸æ“š
        let floatingTexts = [];

        // æ·»åŠ åˆ†æ•¸é£„å­—
        function showScoreFloating(x, y, text, color) {
            floatingTexts.push({
                x: x * CELL_SIZE + CELL_SIZE / 2,
                y: y * CELL_SIZE - 20,
                text: text,
                color: color,
                alpha: 1.0,
                createdAt: Date.now()
            });
        }

        // éŸ³æ•ˆæ§åˆ¶è®Šé‡
        let lastTickSecond = -1;
        let powerWarningPlayed = {}; // è¿½è¹¤æ¯å€‹ç©å®¶æ˜¯å¦å·²æ’­æ”¾è­¦å‘ŠéŸ³

        // æ›´æ–°éŠæˆ²ç‹€æ…‹
        function updateGameState(data) {
            gameState = data;

            // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
            if (data.players) {
                Object.entries(data.players).forEach(([id, player]) => {
                    const scoreEl = document.getElementById(`score-${id}`);
                    if (scoreEl) {
                        scoreEl.textContent = player.score || 0;
                    }
                });
            }
        }

        // ğŸ¤– è™•ç† AI ç©å®¶ç¢°æ’
        function handleAICollision(aiId, aiPlayer, otherId, otherPlayer, now) {
            if (!database) return;

            // æª¢æŸ¥å†·å»æ™‚é–“
            const cooldownKey = `${aiId}_${otherId}`;
            const lastCollision = window.aiCollisionCooldowns = window.aiCollisionCooldowns || {};
            if (lastCollision[cooldownKey] && now - lastCollision[cooldownKey] < TIME_CONSTANTS.COLLISION_COOLDOWN) {
                return; // é‚„åœ¨å†·å»æœŸé–“
            }

            lastCollision[cooldownKey] = now;

            // è¨ˆç®—æ¶åˆ†
            let stealRate = SCORE_STEAL_RATES.NORMAL_VS_NORMAL;

            if (aiPlayer.powerMode && !otherPlayer.powerMode) {
                stealRate = SCORE_STEAL_RATES.POWER_VS_NORMAL;
            } else if (aiPlayer.powerMode && otherPlayer.powerMode) {
                stealRate = SCORE_STEAL_RATES.POWER_VS_POWER;
            }

            const stolenPoints = Math.floor((otherPlayer.score || 0) * stealRate);

            if (stolenPoints > 0) {
                // æ›´æ–° AI ç©å®¶åˆ†æ•¸
                database.ref(`rooms/${currentRoomId}/players/${aiId}/score`)
                    .set((aiPlayer.score || 0) + stolenPoints)
                    .catch(error => console.error('Error updating AI score:', error));

                // æ›´æ–°è¢«æ¶ç©å®¶åˆ†æ•¸
                database.ref(`rooms/${currentRoomId}/players/${otherId}/score`)
                    .set(Math.max(0, (otherPlayer.score || 0) - stolenPoints))
                    .catch(error => console.error('Error updating victim score:', error));

                console.log(`AI ${aiPlayer.name} stole ${stolenPoints} points from ${otherPlayer.name}`);
            }
        }

        // éŠæˆ²å¾ªç’°
        function gameLoop() {
            if (!gameState) return;

            const now = Date.now();

            // è¨ˆç®—éŠæˆ²å‰©é¤˜æ™‚é–“ï¼ˆ3åˆ†é˜ = 180ç§’ï¼‰
            const GAME_DURATION = 180 * 1000; // 3åˆ†é˜ï¼ˆæ¯«ç§’ï¼‰
            const elapsed = now - (gameState.startedAt || now);
            const remaining = Math.max(0, GAME_DURATION - elapsed);
            const remainingSeconds = Math.ceil(remaining / 1000);
            const isLastThirty = remainingSeconds <= 30 && remainingSeconds > 0;

            // æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ
            if (remaining === 0 && gameState.status === 'playing' && isHost && database) {
                // æ™‚é–“åˆ°ï¼çµæŸéŠæˆ²
                database.ref(`rooms/${currentRoomId}`).update({
                    status: 'finished',
                    finishedAt: now
                });
                showGameResults();
                return;
            }

            // ğŸ”Š æœ€å¾Œ30ç§’å€’æ•¸éŸ³æ•ˆï¼ˆæ¯ç§’ä¸€æ¬¡ï¼‰
            if (isLastThirty && remainingSeconds !== lastTickSecond) {
                lastTickSecond = remainingSeconds;
                soundTick();
            }

            // ğŸ”§ æª¢æŸ¥ä¸¦æ¸…é™¤éæœŸçš„ power modeï¼ˆåªæ¸…é™¤è‡ªå·±çš„ç‹€æ…‹ï¼Œé¿å…å¤šæ¬¡æ›´æ–°ï¼‰
            if (gameState.players && database) {
                Object.entries(gameState.players).forEach(([id, player]) => {
                    if (player.powerMode && player.powerEndTime && now >= player.powerEndTime) {
                        // ğŸ”§ åªæ¸…é™¤è‡ªå·±çš„ power mode ç‹€æ…‹ï¼ˆé¿å…æ‰€æœ‰ç©å®¶éƒ½å»æ¸…é™¤å°è‡´å¤šæ¬¡æ›´æ–°ï¼‰
                        if (id === currentPlayerId) {
                            database.ref(`rooms/${currentRoomId}/players/${id}`).update({
                                powerMode: false,
                                powerEndTime: null
                            }).catch(error => {
                                console.error('Error clearing power mode:', error);
                            });
                            console.log('Power mode expired, clearing status');
                        }
                        // æ¸…é™¤è­¦å‘ŠéŸ³æ¨™è¨˜
                        delete powerWarningPlayed[id];
                    } else if (player.powerMode && player.powerEndTime) {
                        // ğŸ”Š æª¢æŸ¥æ˜¯å¦éœ€è¦æ’­æ”¾è­¦å‘ŠéŸ³ï¼ˆæœ€å¾Œ5ç§’ï¼Œä¸”è©²ç©å®¶æ˜¯è‡ªå·±ï¼‰
                        const timeLeft = (player.powerEndTime - now) / 1000;
                        if (timeLeft <= 5 && timeLeft > 4.5 && id === currentPlayerId && !powerWarningPlayed[id]) {
                            soundPowerWarning();
                            powerWarningPlayed[id] = true;
                        }
                    }
                });
            }

            // ğŸ¤– AI æ§åˆ¶é‚è¼¯
            if (aiManager && gameState.players && database && isHost) {
                // æ›´æ–°æ‰€æœ‰ AI çš„ç‹€æ…‹
                aiManager.updateAll(gameState.players);

                // ç²å–æ‰€æœ‰ AI çš„ç§»å‹•æŒ‡ä»¤
                const aiMoves = aiManager.getAllMoves();

                // åŸ·è¡Œ AI ç§»å‹•
                Object.entries(aiMoves).forEach(([aiId, direction]) => {
                    const player = gameState.players[aiId];
                    if (!player) return;

                    // è¨ˆç®—æ–°ä½ç½®
                    let newX = player.x;
                    let newY = player.y;

                    switch (direction) {
                        case 'up': newY--; break;
                        case 'down': newY++; break;
                        case 'left': newX--; break;
                        case 'right': newX++; break;
                    }

                    // æª¢æŸ¥é‚Šç•Œ
                    if (newY < 0 || newY >= ROWS || newX < 0 || newX >= COLS) return;

                    // æª¢æŸ¥ç‰†å£
                    if (gameState.maze && gameState.maze[newY] && gameState.maze[newY][newX] === 1) return;

                    // åŸ·è¡Œç§»å‹•
                    const updates = { x: newX, y: newY };

                    // æª¢æŸ¥æ˜¯å¦åƒåˆ°è±†å­
                    if (gameState.maze && gameState.maze[newY] && gameState.maze[newY][newX] === 2) {
                        updates.score = (player.score || 0) + SCORE_VALUES.DOT;
                        database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                    }

                    // æª¢æŸ¥æ˜¯å¦åƒåˆ°èƒ½é‡è±†
                    if (gameState.maze && gameState.maze[newY] && gameState.maze[newY][newX] === 3) {
                        updates.score = (player.score || 0) + SCORE_VALUES.POWER_PELLET;
                        updates.powerMode = true;
                        updates.powerEndTime = now + TIME_CONSTANTS.POWER_MODE_DURATION;
                        database.ref(`rooms/${currentRoomId}/maze/${newY}/${newX}`).set(0);
                    }

                    // æ›´æ–° AI ç©å®¶ä½ç½®
                    database.ref(`rooms/${currentRoomId}/players/${aiId}`).update(updates)
                        .catch(error => console.error('Error updating AI player:', error));

                    // æª¢æŸ¥ç¢°æ’ï¼ˆAI vs å…¶ä»–ç©å®¶ï¼‰
                    Object.entries(gameState.players).forEach(([otherId, otherPlayer]) => {
                        if (otherId === aiId) return;
                        if (otherPlayer.x === newX && otherPlayer.y === newY) {
                            // ç™¼ç”Ÿç¢°æ’ï¼Œè™•ç†æ¶åˆ†é‚è¼¯
                            handleAICollision(aiId, player, otherId, otherPlayer, now);
                        }
                    });
                });
            }

            // æ¸…ç©ºç•«å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æœ€å¾Œ30ç§’èƒŒæ™¯é–ƒçˆè­¦å‘Š
            if (isLastThirty && Math.floor(now / 500) % 2 === 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // ç¹ªè£½è¿·å®®
            if (gameState.maze) {
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (gameState.maze[y][x] === 1) {
                            ctx.fillStyle = '#0000FF';
                            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                            ctx.strokeStyle = '#4169E1';
                            ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        } else if (gameState.maze[y][x] === 2) {
                            ctx.fillStyle = '#FFF';
                            ctx.beginPath();
                            ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 3, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (gameState.maze[y][x] === 3) {
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#FFA500';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // ç¹ªè£½ç©å®¶
            if (gameState.players) {
                const now = Date.now();
                Object.entries(gameState.players).forEach(([id, player]) => {
                    const centerX = player.x * CELL_SIZE + CELL_SIZE / 2;
                    const centerY = player.y * CELL_SIZE + CELL_SIZE / 2;

                    // æª¢æŸ¥æ˜¯å¦åœ¨ power mode
                    const isPowerMode = player.powerMode && player.powerEndTime && now < player.powerEndTime;
                    const timeRemaining = isPowerMode ? (player.powerEndTime - now) / 1000 : 0;
                    const isWarning = timeRemaining > 0 && timeRemaining <= 5; // æœ€å¾Œ5ç§’è­¦å‘Š
                    const shouldFlash = isWarning && Math.floor(now / 200) % 2 === 0; // 200msé–ƒçˆ

                    // Power mode è¦–è¦ºæ•ˆæœ
                    if (isPowerMode && !shouldFlash) {
                        const baseRadius = CELL_SIZE / 2 - 2;
                        const powerRadius = baseRadius * 1.2; // è®Šå¤§ 1.2 å€

                        // å½©è™¹å…‰æšˆæ•ˆæœï¼ˆå¤šå±¤æ¼¸è®Šåœ“ï¼‰
                        const hue = (now / 50) % 360; // å½©è™¹è‰²ç›¸æ—‹è½‰

                        // å¤–å±¤å…‰æšˆ
                        for (let i = 3; i >= 0; i--) {
                            const gradient = ctx.createRadialGradient(
                                centerX, centerY, powerRadius,
                                centerX, centerY, powerRadius + 6 + i * 2
                            );
                            gradient.addColorStop(0, `hsla(${(hue + i * 30) % 360}, 100%, 50%, 0.4)`);
                            gradient.addColorStop(1, `hsla(${(hue + i * 30) % 360}, 100%, 50%, 0)`);

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, powerRadius + 8 + i * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // ç©å®¶æœ¬é«”ï¼ˆæ›´å¤§ï¼‰
                        ctx.fillStyle = player.color;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, powerRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // çœ¼ç›ï¼ˆæ”¾å¤§ï¼‰
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(centerX - 4, centerY - 3, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(centerX + 4, centerY - 3, 2.5, 0, Math.PI * 2);
                        ctx.fill();

                        // ğŸ”¥ èƒ½é‡è±†å€’æ•¸é€²åº¦æ¢ï¼ˆé ­é ‚ï¼‰
                        if (isPowerMode) {
                            const barWidth = 30;
                            const barHeight = 4;
                            const barX = centerX - barWidth / 2;
                            const barY = player.y * CELL_SIZE - 15;

                            // è¨ˆç®—å‰©é¤˜æ¯”ä¾‹
                            const maxDuration = 15; // 15 ç§’
                            const progress = Math.max(0, Math.min(1, timeRemaining / maxDuration));

                            // èƒŒæ™¯æ¡†
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                            ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);

                            // é€²åº¦æ¢ï¼ˆé¡è‰²æ ¹æ“šå‰©é¤˜æ™‚é–“è®ŠåŒ–ï¼‰
                            let barColor;
                            if (timeRemaining > 10) {
                                barColor = '#00FF00'; // ç¶ è‰² (10-15ç§’)
                            } else if (timeRemaining > 5) {
                                barColor = '#FFFF00'; // é»ƒè‰² (5-10ç§’)
                            } else {
                                barColor = '#FF0000'; // ç´…è‰² (0-5ç§’)
                            }

                            ctx.fillStyle = barColor;
                            ctx.fillRect(barX, barY, barWidth * progress, barHeight);

                            // å€’æ•¸æ•¸å­—ï¼ˆæœ€å¾Œ5ç§’ï¼‰
                            if (isWarning) {
                                ctx.fillStyle = '#FF0000';
                                ctx.font = 'bold 10px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText(Math.ceil(timeRemaining), centerX, barY - 3);
                            }
                        }
                    } else {
                        // æ™®é€šæ¨¡å¼æˆ–é–ƒçˆæ™‚é¡¯ç¤ºæ™®é€šå¤–è§€
                        const normalRadius = CELL_SIZE / 2 - 2;

                        ctx.fillStyle = player.color;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, normalRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // çœ¼ç›
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(centerX - 3, centerY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(centerX + 3, centerY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // åå­—ï¼ˆå§‹çµ‚é¡¯ç¤ºï¼‰
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeText(player.name, centerX, player.y * CELL_SIZE - 5);
                    ctx.fillText(player.name, centerX, player.y * CELL_SIZE - 5);
                });
            }

            // ç¹ªè£½è¨ˆæ™‚å™¨ï¼ˆé ‚éƒ¨ä¸­å¤®ï¼‰
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            const timeText = `â±ï¸ ${minutes}:${seconds.toString().padStart(2, '0')}`;

            ctx.save();
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';

            // æœ€å¾Œ30ç§’ç´…è‰²é–ƒçˆ
            if (isLastThirty) {
                const flashIntensity = Math.floor(now / 250) % 2 === 0 ? 1.0 : 0.6;
                ctx.fillStyle = `rgba(255, 0, 0, ${flashIntensity})`;
                ctx.strokeStyle = '#FFF';
            } else {
                ctx.fillStyle = '#FFF';
                ctx.strokeStyle = '#000';
            }

            ctx.lineWidth = 4;
            ctx.strokeText(timeText, canvas.width / 2, 40);
            ctx.fillText(timeText, canvas.width / 2, 40);
            ctx.restore();

            // æœ€å¾Œ30ç§’è­¦å‘Šæ–‡å­—
            if (isLastThirty) {
                ctx.save();
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#FF0000';
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 3;
                const warningText = t('warning30sec');
                ctx.strokeText(warningText, canvas.width / 2, 70);
                ctx.fillText(warningText, canvas.width / 2, 70);
                ctx.restore();
            }

            // ğŸ† ç¹ªè£½å³æ™‚æ’åï¼ˆå³ä¸Šè§’ï¼‰
            if (gameState.players) {
                // è¨ˆç®—æ’å
                const rankings = Object.entries(gameState.players)
                    .map(([id, player]) => ({
                        id,
                        name: player.name,
                        color: player.color,
                        score: player.score || 0
                    }))
                    .sort((a, b) => b.score - a.score);

                // æ‰¾åˆ°è‡ªå·±çš„æ’å
                const myRank = rankings.findIndex(p => p.id === currentPlayerId);
                const isInTop3 = myRank < 3;

                // èƒŒæ™¯æ¡†
                const boxX = canvas.width - 220;
                const boxY = 95;
                const boxWidth = 210;
                const boxHeight = isInTop3 ? 145 : 200; // å¦‚æœä¸åœ¨å‰3ï¼Œå¤šé¡¯ç¤ºè‡ªå·±

                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // æ¨™é¡Œ
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFD700';
                ctx.fillText(t('ranking'), boxX + 10, boxY + 28);

                // é¡¯ç¤ºå‰3å
                let yPos = boxY + 60;
                const topPlayers = rankings.slice(0, 3);

                topPlayers.forEach((player, index) => {
                    const isMe = player.id === currentPlayerId;
                    const rank = index + 1;

                    // é«˜äº®è‡ªå·±
                    if (isMe) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                        ctx.fillRect(boxX + 5, yPos - 20, boxWidth - 10, 28);
                    }

                    // æ’å
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : '#CD7F32';
                    ctx.fillText(`#${rank}`, boxX + 15, yPos);

                    // ç©å®¶é¡è‰²é»
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.arc(boxX + 50, yPos - 5, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // ç©å®¶åå­—
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#FFF';
                    ctx.textAlign = 'left';
                    const displayName = player.name.length > 8 ? player.name.substring(0, 7) + '...' : player.name;
                    ctx.fillText(displayName + (isMe ? ' ' + t('you') : ''), boxX + 62, yPos);

                    // åˆ†æ•¸
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(player.score.toString(), boxX + boxWidth - 15, yPos);

                    yPos += 30;
                });

                // å¦‚æœè‡ªå·±ä¸åœ¨å‰3ï¼Œé¡¯ç¤ºåˆ†éš”ç·š + è‡ªå·±çš„æ’å
                if (!isInTop3 && myRank >= 0) {
                    // åˆ†éš”ç·š
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(boxX + 10, yPos + 5);
                    ctx.lineTo(boxX + boxWidth - 10, yPos + 5);
                    ctx.stroke();

                    yPos += 25;

                    const myPlayer = rankings[myRank];

                    // é«˜äº®èƒŒæ™¯
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.fillRect(boxX + 5, yPos - 20, boxWidth - 10, 28);

                    // æˆ‘çš„æ’å
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(`#${myRank + 1}`, boxX + 15, yPos);

                    // ç©å®¶é¡è‰²é»
                    ctx.fillStyle = myPlayer.color;
                    ctx.beginPath();
                    ctx.arc(boxX + 50, yPos - 5, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // ç©å®¶åå­—
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#FFF';
                    ctx.textAlign = 'left';
                    const displayName = myPlayer.name.length > 8 ? myPlayer.name.substring(0, 7) + '...' : myPlayer.name;
                    ctx.fillText(displayName + ' ' + t('you'), boxX + 62, yPos);

                    // åˆ†æ•¸
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(myPlayer.score.toString(), boxX + boxWidth - 15, yPos);
                }

                ctx.restore();
            }

            // ç¹ªè£½åˆ†æ•¸é£„å­—å‹•ç•«
            floatingTexts = floatingTexts.filter(ft => {
                const elapsed = now - ft.createdAt;
                if (elapsed > 1500) return false; // 1.5ç§’å¾Œç§»é™¤

                // è¨ˆç®—å‹•ç•«åƒæ•¸
                ft.y -= 0.5; // å‘ä¸Šé£„
                ft.alpha = Math.max(0, 1 - elapsed / 1500); // æ·¡å‡º

                // ç¹ªè£½
                ctx.save();
                ctx.globalAlpha = ft.alpha;
                ctx.fillStyle = ft.color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(ft.text, ft.x, ft.y);
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();

                return true; // ä¿ç•™
            });

            requestAnimationFrame(gameLoop);
        }
        
        /**
         * é¡¯ç¤ºéŠæˆ²çµç®—ç•«é¢
         *
         * æ”¹é€²é»ï¼š
         * 1. åŠ å…¥æˆ¿é–“è‡ªå‹•æ¸…ç†ï¼ˆ20ç§’å¾Œåˆªé™¤æˆ¿é–“æ•¸æ“šï¼‰
         * 2. æ›´å¥½çš„éŒ¯èª¤è™•ç†
         */
        function showGameResults() {
            if (!gameState || !gameState.players) return;

            // ğŸ”Š éŠæˆ²çµæŸéŸ³æ•ˆ
            soundGameEnd();

            // ä¿å­˜ç©å®¶æ•¸æ“šå¾Œåœæ­¢éŠæˆ²å¾ªç’°
            const finalPlayers = gameState.players;
            const roomIdToClean = currentRoomId; // ä¿å­˜æˆ¿é–“ ID
            gameState = null;

            // è¨ˆç®—æ’å
            const rankings = Object.entries(finalPlayers || {})
                .map(([id, player]) => ({
                    id,
                    name: player.name,
                    color: player.color,
                    score: player.score || 0
                }))
                .sort((a, b) => b.score - a.score);

            // æ¸…ç©ºç•«å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç¹ªè£½æ¨™é¡Œ
            ctx.save();
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 5;
            ctx.strokeText(t('gameOver'), canvas.width / 2, 80);
            ctx.fillText(t('gameOver'), canvas.width / 2, 80);
            ctx.restore();

            // ç¹ªè£½æ’å
            let startY = 150;
            const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];

            rankings.forEach((player, index) => {
                const isMe = player.id === currentPlayerId;
                const y = startY + index * 60;

                // èƒŒæ™¯ï¼ˆè‡ªå·±çš„æ’åé«˜äº®ï¼‰
                if (isMe) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.fillRect(canvas.width / 2 - 300, y - 35, 600, 55);
                }

                // æ’åæ•¸å­—æˆ–çç‰Œ
                ctx.save();
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFF';

                const rankText = index < 3 ? medals[index] : `#${index + 1}`;
                ctx.fillText(rankText, canvas.width / 2 - 200, y);

                // ç©å®¶é¡è‰²é»
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(canvas.width / 2 - 160, y - 10, 15, 0, Math.PI * 2);
                ctx.fill();

                // ç©å®¶åå­—
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFF';
                const nameText = `${player.name}${isMe ? ' ' + t('you') : ''}`;
                ctx.fillText(nameText, canvas.width / 2 - 130, y);

                // åˆ†æ•¸
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFD700';
                ctx.fillText(`${player.score} ${t('points')}`, canvas.width / 2 + 250, y);

                ctx.restore();
            });

            // ç¹ªè£½æç¤ºæ–‡å­—
            ctx.save();
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#AAA';
            ctx.fillText(t('autoReturn'), canvas.width / 2, canvas.height - 50);
            ctx.restore();

            // 15ç§’å¾Œè‡ªå‹•è¿”å›å¤§å»³
            setTimeout(() => {
                window.location.reload();
            }, 15000);

            // ğŸ”§ 20ç§’å¾Œè‡ªå‹•æ¸…ç†æˆ¿é–“æ•¸æ“šï¼ˆåªæœ‰ Host åŸ·è¡Œï¼‰
            if (isHost && database && roomIdToClean) {
                setTimeout(async () => {
                    try {
                        await database.ref(`rooms/${roomIdToClean}`).remove();
                        console.log(`Room ${roomIdToClean} cleaned up successfully`);
                    } catch (error) {
                        console.error('Error cleaning up room:', error);
                    }
                }, 20000); // 20ç§’å¾Œæ¸…ç†ï¼ˆçµ¦æ‰€æœ‰ç©å®¶è¶³å¤ æ™‚é–“çœ‹çµç®—ï¼‰
            }
        }

        // é›¢é–‹æˆ¿é–“
        async function leaveRoom() {
            if (currentRoomId && currentPlayerId && database) {
                const playerRef = database.ref(`rooms/${currentRoomId}/players/${currentPlayerId}`);
                await playerRef.remove();
            }
            window.location.reload();
        }

        // ==================== PWA æ”¯æ´ ====================

        /**
         * ğŸ“± è¨»å†Š Service Worker
         * æä¾›é›¢ç·šæ”¯æ´å’Œå¿«å–åŠŸèƒ½
         */
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then((registration) => {
                        console.log('âœ… Service Worker è¨»å†ŠæˆåŠŸ:', registration.scope);

                        // æª¢æŸ¥æ›´æ–°
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('ğŸ”„ ç™¼ç¾æ–°ç‰ˆæœ¬ Service Worker');

                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // æ–°ç‰ˆæœ¬å¯ç”¨ï¼Œæç¤ºç”¨æˆ¶é‡æ–°è¼‰å…¥
                                    if (confirm('ç™¼ç¾æ–°ç‰ˆæœ¬ï¼æ˜¯å¦ç«‹å³æ›´æ–°ï¼Ÿ')) {
                                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('âŒ Service Worker è¨»å†Šå¤±æ•—:', error);
                    });

                // Service Worker æ›´æ–°å¾Œè‡ªå‹•é‡æ–°è¼‰å…¥
                let refreshing = false;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (!refreshing) {
                        refreshing = true;
                        window.location.reload();
                    }
                });
            });
        }

        /**
         * ğŸ® è§¸æ§éœ‡å‹•å›é¥‹
         * ç‚ºç§»å‹•ç«¯æä¾›è§¸è¦ºåé¥‹
         */
        const vibrate = {
            // åƒè±†å­éœ‡å‹• (çŸ­ä¿ƒ)
            eatDot: () => {
                if ('vibrate' in navigator) {
                    navigator.vibrate(30);
                }
            },

            // åƒèƒ½é‡è±†éœ‡å‹• (ä¸­ç­‰)
            eatPowerPellet: () => {
                if ('vibrate' in navigator) {
                    navigator.vibrate([50, 30, 50]);
                }
            },

            // ç¢°æ’éœ‡å‹• (å¼·çƒˆ)
            collision: () => {
                if ('vibrate' in navigator) {
                    navigator.vibrate([100, 50, 100, 50, 100]);
                }
            },

            // éŠæˆ²é–‹å§‹éœ‡å‹•
            gameStart: () => {
                if ('vibrate' in navigator) {
                    navigator.vibrate([50, 100, 50]);
                }
            },

            // éŠæˆ²çµæŸéœ‡å‹•
            gameEnd: () => {
                if ('vibrate' in navigator) {
                    navigator.vibrate([200, 100, 200, 100, 200]);
                }
            },

            // æŒ‰éˆ•é»æ“Šéœ‡å‹• (æ¥µçŸ­)
            buttonClick: () => {
                if ('vibrate' in navigator) {
                    navigator.vibrate(10);
                }
            }
        };

        // å°‡éœ‡å‹•åŠŸèƒ½åŠ å…¥å…¨åŸŸ (æ–¹ä¾¿å…¶ä»–å‡½æ•¸èª¿ç”¨)
        window.gameVibrate = vibrate;

        /**
         * ğŸ”” PWA å®‰è£æç¤º
         * æç¤ºç”¨æˆ¶å°‡éŠæˆ²å®‰è£åˆ°ä¸»ç•«é¢
         */
        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('ğŸ’¡ PWA å¯ä»¥å®‰è£');
            e.preventDefault();
            deferredPrompt = e;

            // é¡¯ç¤ºå®‰è£æç¤ºï¼ˆå¯é¸ï¼‰
            const installBanner = document.createElement('div');
            installBanner.id = 'install-banner';
            installBanner.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px 25px;
                border-radius: 25px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
                z-index: 9999;
                display: flex;
                gap: 10px;
                align-items: center;
                font-weight: bold;
                cursor: pointer;
                animation: slideUp 0.5s ease-out;
            `;
            installBanner.innerHTML = `
                <span>ğŸ“±</span>
                <span>å®‰è£éŠæˆ²åˆ°ä¸»ç•«é¢</span>
                <button id="install-button" style="
                    background: white;
                    color: #764ba2;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 15px;
                    font-weight: bold;
                    cursor: pointer;
                ">å®‰è£</button>
                <button id="install-dismiss" style="
                    background: transparent;
                    color: white;
                    border: 1px solid white;
                    padding: 8px 16px;
                    border-radius: 15px;
                    cursor: pointer;
                ">ç¨å¾Œ</button>
            `;

            document.body.appendChild(installBanner);

            // å®‰è£æŒ‰éˆ•äº‹ä»¶
            document.getElementById('install-button')?.addEventListener('click', async () => {
                vibrate.buttonClick();
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`PWA å®‰è£çµæœ: ${outcome}`);
                    deferredPrompt = null;
                    installBanner.remove();
                }
            });

            // ç¨å¾ŒæŒ‰éˆ•äº‹ä»¶
            document.getElementById('install-dismiss')?.addEventListener('click', () => {
                vibrate.buttonClick();
                installBanner.remove();
            });
        });

        // PWA å®‰è£æˆåŠŸ
        window.addEventListener('appinstalled', () => {
            console.log('âœ… PWA å®‰è£æˆåŠŸ');
            vibrate.gameStart();
            deferredPrompt = null;
        });

        // é é¢è¼‰å…¥å¾Œè¨­å®šäº‹ä»¶ç›£è½å™¨
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up event listeners');
            
            const btnShowCreate = document.getElementById('btnShowCreate');
            const btnShowJoin = document.getElementById('btnShowJoin');
            const btnCreateRoom = document.getElementById('btnCreateRoom');
            const btnJoinRoom = document.getElementById('btnJoinRoom');
            
            console.log('Button elements:', {
                btnShowCreate: btnShowCreate ? 'Found' : 'Not found',
                btnShowJoin: btnShowJoin ? 'Found' : 'Not found',
                btnCreateRoom: btnCreateRoom ? 'Found' : 'Not found',
                btnJoinRoom: btnJoinRoom ? 'Found' : 'Not found'
            });
            
            btnShowCreate.addEventListener('click', function() {
                console.log('btnShowCreate clicked');
                showCreateRoom();
            });
            btnShowJoin.addEventListener('click', function() {
                console.log('btnShowJoin clicked');
                showJoinRoom();
            });
            btnCreateRoom.addEventListener('click', function() {
                console.log('btnCreateRoom clicked');
                createRoom();
            });
            btnJoinRoom.addEventListener('click', function() {
                console.log('btnJoinRoom clicked');
                joinRoom();
            });
            document.getElementById('btnBackFromCreate').addEventListener('click', backToMenu);
            document.getElementById('btnBackFromJoin').addEventListener('click', backToMenu);
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('btnLeaveLobby').addEventListener('click', leaveRoom);
            document.getElementById('btnLeaveGame').addEventListener('click', leaveRoom);

            // âš¡ å–®äººç·´ç¿’æ¨¡å¼
            document.getElementById('btnSoloPractice').addEventListener('click', function() {
                console.log('Solo Practice clicked');
                startSoloPractice();
            });

            // â“ å¦‚ä½•éŠç©
            document.getElementById('btnHowToPlay').addEventListener('click', function() {
                console.log('How to Play clicked');
                showHowToPlay();
            });

            // è¿”å›ä¸»é¸å–®ï¼ˆå¾èªªæ˜é é¢ï¼‰
            document.getElementById('btnBackFromHowToPlay').addEventListener('click', function() {
                console.log('Back from How to Play');
                backToMenuFromHowToPlay();
            });

            // éŸ³æ•ˆé–‹é—œ
            document.getElementById('btnToggleSound').addEventListener('click', function() {
                isSoundEnabled = !isSoundEnabled;
                updateSoundButtonText();
                // æ¸¬è©¦éŸ³æ•ˆ
                if (isSoundEnabled) soundEatDot();
            });

            // èªè¨€åˆ‡æ›æŒ‰éˆ•
            document.getElementById('languageToggle').addEventListener('click', function() {
                toggleLanguage();
            });

            // åˆå§‹åŒ–èªè¨€è¨­å®š
            updateUILanguage();

            // ğŸ¤– AI é…ç½®äº‹ä»¶ç›£è½å™¨
            const enableAICheckbox = document.getElementById('enableAI');
            const aiConfigSection = document.getElementById('aiConfigSection');
            const aiCountSlider = document.getElementById('aiCount');
            const aiCountValue = document.getElementById('aiCountValue');
            const aiDifficultySelect = document.getElementById('aiDifficulty');

            // AI å•Ÿç”¨/ç¦ç”¨åˆ‡æ›
            enableAICheckbox.addEventListener('change', function() {
                aiEnabled = this.checked;
                aiConfigSection.style.display = aiEnabled ? 'block' : 'none';
                console.log('AI enabled:', aiEnabled);
            });

            // AI æ•¸é‡æ»‘æ¡¿
            aiCountSlider.addEventListener('input', function() {
                aiCount = parseInt(this.value);
                aiCountValue.textContent = aiCount;
                console.log('AI count:', aiCount);
            });

            // AI é›£åº¦é¸æ“‡
            aiDifficultySelect.addEventListener('change', function() {
                aiDifficulty = this.value;
                console.log('AI difficulty:', aiDifficulty);
            });

            // Enter éµæ”¯æŒ
            document.getElementById('hostName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createRoom();
            });
            document.getElementById('playerName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            document.getElementById('roomCode').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            console.log('Event listeners set up successfully');
        });
    </script>
</body>
</html>